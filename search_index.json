[["index.html", ",          ", " ,           2021-07-14   .    .        .      ,         (  R),       House of Europe. :  ,  ,  ,   "],["chapter1.html", " 1    1.1   R? 1.2   R 1.3    R 1.4      R", "  1       R?   R    R R Project    R   R GUI        (help/?)   R Studio    RStudio Desktop     RStudio   Jupyter Notebook   IDE      R      R          RStudio 1.1   R? R         (DataScience)    (Machine Learning).      R    : ,  .    R       ,                       / .  ,    R   (free)     (open source). R    ,    :  .    ,   ,       .   .     ,       (, MS Excel), R                 .  . R    ,    ,           .    ,         , , caret  mlr. .              (deployment)          (pipeline).        -  , ,    (shiny, shinydashboard, flexdashboard, rmarkdown, knitr ),             . 1.2   R   R      S.   S     C.  S   1976   Bell Labs.  S         .    S-Plus,          Windows  Unix-,    .       R.  1993         ,    R ( ,   R   ,     S   ,      C,    B) (.. , .. , .. , .. , .. , .. , .. . 2012).    (Robert Gentelman  Ross Ihaka)        S,    S-Plus  , ,      ,  .     ,    S.       ,      R  ,        (),   , , ,     S-Plus  R.          R,          (SAS, Stata, SYSSTAT).           R                 ,  ,   ,   . 1.3    R 1.3.1 R Project R    ,     GNU General Public License. ,   R      : UNIX, Windows, MacOS (R Core Team 2020). 1.3.1.1    R     R      https://cran.r-project.org/.     R    .       Windows,            : . 1.1:  R.        install R for the first time: . 1.2:  R.     Download R 4.X.X for Windows,  4.X.X  R,        : . 1.3:  R.           .                . ,   Google Chrome     : . 1.4:  R.    Google Chrome             .                        ,    . 1.3.1.2   R GUI        C:\\Program Files\\R\\R-4.X.X.   R GUI (      R)     bin\\x64 ( i386,    32-  )    Rgui.exe.   R GUI  : . 1.5:    RGui GUI (Graphical User Interface) -          .   R Console   / R,   :               : . 1.6:     RGui  R GUI        -     R,         R.       R-. 1.3.1.3         /      .  R      ,    ,         ,         (               ).      var1, var2      : var1 &lt;- 10 var2 &lt;- sqrt(15) var1 ## [1] 10 var2 ## [1] 3.872983            ls(): ls() ## [1] &quot;var1&quot; &quot;var2&quot;            rm(). ,       rm(list = ls()),       / ,    : rm(list = c(&quot;var1&quot;)) ls() ## [1] &quot;var2&quot;  ,    ,    var2.   (image)         save.image(\"  .RData\"),      load(\"  .RData\"): # Clear workspace rm(list = ls()) # declare data a &lt;- 10 b &lt;- a + 15 # Save image to file save.image(&quot;tmp.RData&quot;) # Clear workspace rm(list = ls()) # load image to file load(&quot;tmp.RData&quot;) print(a) ## [1] 10 print(b) ## [1] 25   2    ,      .        ,       R    .RDS,    saveRDS(', file=\"_.rds\")  readRDS(file=\"_.rds\"). 1.3.1.4      -      ,      .        ,                 .     R      getwd().    RStudio   ,          : getwd() ## [1] &quot;E:/Repos/YuRa/r-science-dev&quot;          setwd().      getwd()      /.             ,                .      Windows   2- : / - ,    ; \\\\ - ,    .           (drive -  ): setwd(&quot;drive:/folder1/folder2/&quot;) setwd(&quot;drive:\\\\folder1\\\\folder2\\\\&quot;)                dir()  list.files(): dir() ## [1] &quot;_bookdown.yml&quot; &quot;_bookdown_files&quot; &quot;_output.yml&quot; ## [4] &quot;01-chapter1.Rmd&quot; &quot;01-chapter1_files&quot; &quot;01-intro_files&quot; ## [7] &quot;02-chapter2.Rmd&quot; &quot;02-chapter2_files&quot; &quot;03-chapter3.Rmd&quot; ## [10] &quot;03-chapter3_files&quot; &quot;04-chapter4.Rmd&quot; &quot;04-chapter4_files&quot; ## [13] &quot;05-chapter5.Rmd&quot; &quot;05-chapter5_files&quot; &quot;06-chapter6.Rmd&quot; ## [16] &quot;07-chapter7.Rmd&quot; &quot;09-chapter9.Rmd&quot; &quot;10-references.Rmd&quot; ## [19] &quot;book.bib&quot; &quot;css&quot; &quot;data&quot; ## [22] &quot;favicon.ico&quot; &quot;images&quot; &quot;inc&quot; ## [25] &quot;index.md&quot; &quot;index.Rmd&quot; &quot;packages.bib&quot; ## [28] &quot;preamble.tex&quot; &quot;r-science.log&quot; &quot;r-science.rds&quot; ## [31] &quot;README.md&quot; &quot;render_commands&quot; &quot;render51b043e751e2.rds&quot; ## [34] &quot;RScience.Rproj&quot; &quot;sss.R&quot; &quot;tmp.R&quot; ## [37] &quot;tmp.RData&quot; list.files() ## [1] &quot;_bookdown.yml&quot; &quot;_bookdown_files&quot; &quot;_output.yml&quot; ## [4] &quot;01-chapter1.Rmd&quot; &quot;01-chapter1_files&quot; &quot;01-intro_files&quot; ## [7] &quot;02-chapter2.Rmd&quot; &quot;02-chapter2_files&quot; &quot;03-chapter3.Rmd&quot; ## [10] &quot;03-chapter3_files&quot; &quot;04-chapter4.Rmd&quot; &quot;04-chapter4_files&quot; ## [13] &quot;05-chapter5.Rmd&quot; &quot;05-chapter5_files&quot; &quot;06-chapter6.Rmd&quot; ## [16] &quot;07-chapter7.Rmd&quot; &quot;09-chapter9.Rmd&quot; &quot;10-references.Rmd&quot; ## [19] &quot;book.bib&quot; &quot;css&quot; &quot;data&quot; ## [22] &quot;favicon.ico&quot; &quot;images&quot; &quot;inc&quot; ## [25] &quot;index.md&quot; &quot;index.Rmd&quot; &quot;packages.bib&quot; ## [28] &quot;preamble.tex&quot; &quot;r-science.log&quot; &quot;r-science.rds&quot; ## [31] &quot;README.md&quot; &quot;render_commands&quot; &quot;render51b043e751e2.rds&quot; ## [34] &quot;RScience.Rproj&quot; &quot;sss.R&quot; &quot;tmp.R&quot; ## [37] &quot;tmp.RData&quot; 1.3.1.5  (help/?)      R    help(_'__)  ?_'__: # Get help for intersect() function help(intersect)        : help(package = &quot;stats&quot;) 1.3.2   R Studio 1.3.2.1    RStudio Desktop RStudio -      R.     ,   (),   ,    , html-,   ,  ,   ,       . RStudio          Windows, Linux  Mac,   -    Linux RStudio Server  RStudio Server Pro (RStudio Official Website 2021). IDE (integrated development environment) -       . ,     ,       .        . Wikipedia      https://rstudio.com.   ,            :      Products &gt; RStudio.        RStudio Desktop  Open Source   DOWNLOAD RSTUDIO DESKTOP: . 1.7:   RStudio Desktop      RStudio Desktop   : . 1.8:  RStudio Desktop     RStudio.      .   IDE RStudio    3-  4- : * ,     ( ). *        ( ). *   (Environment) ( ) +   (History),     , ,   (Connections),   (Tutorial). *     (Files),   (Packages),  (Help),   (Plots, Viewer). . 1.9:   RStudio Desktop        2  : . 1.10:     RStudio Desktop     data &lt;- c(3,7,1,6,3,4,5,4,2)     .  ,    Environments   ,       (   ).   plot(data, type=\"l\")      (type=\"l\" - linear, \"p\" - point, help(plot)  ). ,        Plots.          ,     html/css/js,       View.     History,       .          (Console)    Up/Down  : 1.3.2.2     RStudio {chapter1322}    R Gui  RStudio   ,             .    .        File &gt; New Project.        New Directory.   ,               . . 1.11: RStudio Desktop.       New Project: . 1.12: RStudio Desktop.  .      Create Project       .              ,     .       *.Rproj   Windows. . 1.13: RStudio Desktop.         R      File &gt; New file &gt; R Script    Ctrl+Shift+N.       Untitled[X],     , ,  TestCode.R      :  ,     20-     [1;5],     ,        (      ).    20-     [1;5]   : vtr &lt;- sample(1:5, 20, replace=TRUE) vtr ## [1] 5 5 3 5 4 3 5 3 5 5 2 4 3 4 4 2 2 1 5 3       ,            .    set.seed(  - ). P.S.     ,   set.seed()  R  4+     3+.      .           : vtr_sum &lt;- sum(vtr) vtr_mean &lt;- mean(vtr) print(paste0(&quot;Sum: &quot;, vtr_sum)) ## [1] &quot;Sum: 73&quot; print(paste0(&quot;Mean: &quot;, vtr_mean)) ## [1] &quot;Mean: 3.65&quot;  : hist(vtr, breaks = 5) . 1.14:     R .     hist()   : https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/hist.    RStudio         : . 1.15: RStudio Desktop.         Environment,      ,       '.            ,  .       . 1.3.3   Jupyter Notebook         ,        .      ,       ,         . _*.        ._           ,   ,         .            .      Anaconda (       Data Science)  Jupyter Notebook  .    Anaconda          : https://www.anaconda.com/products/individual (Anaconda. The Worlds Most Popular Data Science Platform 2021). _*.          Windows 10 Education_.    Anaconda         Windows.   Anaconda Navigator          R: Anaconda       Environments   Create: . 1.16: Anaconda.    ,     [x]      R: . 1.17: Anaconda.      R   R-     Home   : . 1.18: Anaconda.        Launch   Jupyter Notebook    . Jupyter Notebook        .      ,       New &gt; Notebook &gt; R: . 1.19: Jupyter Notebook.    1.3.4   IDE      R         ,       R-.   . Visual Studio Code -     Microsoft,         (Visual Studio Code 2021).     VS Code       R: . 1.20: Visual Studio Code.  RTools Visual Studio Community Edition -      Microsoft. VS         .NET    C#, VB.NET, F# ,      ,     ,      R (Visual Studio Community Edition 2021). Google Collab -        Data Science   Google (Google Colaboratory 2021): . 1.21: Google Collab .       Python. kaggle.com -     Data Science  Machine Learning.   ,       . . 1.22: Kaggle.com        R       ,            . 1.4      R 1.4.1        R ,   ,             .        ,      .   R -               R.          ,       .         cran.r-project.org / (R Core Team 2020)    (dev-    github).    R      ,       .      install.packages(): install.packages(&quot;fun&quot;)         library(): packageDescription(&quot;fun&quot;) help(package = &quot;fun&quot;)          DataCamp: R Packages: A Beginners Guide. 1.4.2     RStudio     RStudio            ,    .         Tools: . 1.23: RStudio Desktop.      Install Packages...  ,             ,      : . 1.24: RStudio Desktop.     RStudio     /,        (   ): . 1.25: RStudio Desktop.               _::_()      library(): . 1.26: RStudio Desktop.    fun       ,           . e "],["chapter2.html", " 2    R:    .  1 2.1     2.2    2.3  2.4    2.5 - ", "  2    R:    .  1 :  ,                     R                 (round, ceiling, floor, trunc, signif)   (seq, rep)         R -  2.1     2.1.1             .            , ,   . ,   my_variable  10  : my_variable &lt;- 5  my_variable = 5.         . !  ,   (&lt;-, =)   (==)   .  ==      /        TRUE (  )  FALSE (   ).  &lt;-        ,     =.   R        &lt;-.     R    &lt;&lt;-, -&gt;, -&gt;&gt;.       .         R &lt;-  = : Why do we use arrow as an assignment operator? (Colin FAY). Difference between assignment operators in R (Ren Kun). Assignment Operators. : x &lt;- 45 y &lt;- 10 z &lt;- x + y # z = 45 + 10 z ## [1] 55  ,  :      x     45.      y     10.      z      x + y. #  R    ,     .         z. 2.1.2           R: 1.       [a-z, A-z],  [0-9],  .    _. 2.        .     ,      . 3.           , , TRUE/FALSE.       (space).       ,      _   .. ,    my_variable_name  my.variable.name.  myVariableName (camel case)       R,       .    : total, zminna, Sum, .length_of_something, Number123, x_1.    : tot@l, 5x_1, _variable, FALSE, .0ne. 2.2    2.2.1   R          .   -       ,     . , ,        ,   .   (  )        ,  (       ),     .  R,       ,              .       C# (   C/Java): int a = 10; a = &quot;some text&quot;;    C#     a  int (integer -  ),      a   ( string  #).         .     R: a &lt;- 10 a &lt;- &quot;some text&quot; a ## [1] &quot;some text&quot;         some text,   1      ,   - .   R   ,           .   ,     .      R  :     (decimal numbers),  , 4.0, 15.214,   numeric(s).   (natural numbers),  , 4, 15,   integer(s).   (boolean values),  TRUE  FALSE (     T  F),   logical.    (string values),  , \"Hello\", \"12 is number\",   character(s).     : my_numeric - , my_character - , my_logical -  . my_numeric &lt;- 5 my_character &lt;- &quot;universe&quot; my_logical &lt;- FALSE   my_character &lt;- \"5\"     : my_character &lt;- &quot;5&quot; my_sum &lt;- my_numeric + my_character        ,   5  \"5\"     ,      class(): class(5) ## [1] &quot;numeric&quot; class(&quot;5&quot;) ## [1] &quot;character&quot;   class(5)  ,  5     numeric,  class(\"5\")   character,        . 2.2.2                /       .    -         .  ,         . , ,  \"5\" (character)      5 (numeric),  \"five\"     .            is._().    TRUE,       FALSE,   .  : my_numeric &lt;- 5 my_character &lt;- &quot;five&quot; my_logical &lt;- FALSE is.numeric(my_numeric) ## [1] TRUE is.character(my_numeric) ## [1] FALSE        as._().             NA,      : a &lt;- 5 b &lt;- &quot;10&quot; c &lt;- &quot;10, 20&quot; as.numeric(b) ## [1] 10 as.numeric(c) ## Warning: NAs introduced by coercion ## [1] NA            : a &lt;- 5 b &lt;- &quot;10&quot; b &lt;- as.numeric(b) a + b ## [1] 15 number &lt;- as.integer(54) typeof(number) ## [1] &quot;integer&quot; class(number) ## [1] &quot;integer&quot;            :         Array is.array as.array Character is.character as.character Complex is.complex as.complex Dataframe is.data.frame as.data.frame Double is.double as.double Factor is.factor as.factor List is.list as.list Logical is.logical as.logical Matrix is.matrix as.matrix Numeric is.numeric as.numeric Raw is.raw as.raw Time series (ts) is.ts as.ts Vector is.vector as.vector 2.3  2.3.1   R     .     ,     : * : +. * : -. * : /. * : *.     : *   : ^ (    Shift+6  ENG- ). *    (     ): %% (    Shift+5). *  : %/%.    : 5 + 10 ## [1] 15 5 + 4 + 15 ## [1] 24 5 + 53 + 343 ## [1] 401 (5 + 8) + (4 + 9) ## [1] 26 .             .    : 47 - 21 ## [1] 26 15 - (10 - 25) ## [1] 30 .   /          :)   : 5 * 3 ## [1] 15 5 * (2 + 5) ## [1] 35   : 12 / 2 ## [1] 6 (4 + 7) / 3 ## [1] 3.666667       ^   . , , 3^2  9,  2^3 -  2*2*2   8. 5^2 ## [1] 25 (1+3)^3 + 100 ## [1] 164             . ,     5  2  1,  2 * 2 (=4) + 1 = 5 28 %% 7 ## [1] 0 17%%5 ## [1] 2         : 28 %/% 7 ## [1] 4 17 %/% 5 ## [1] 3 Sys.setlocale(&quot;LC_CTYPE&quot;, &quot;ukrainian&quot;) ## [1] &quot;Ukrainian_Ukraine.1251&quot; #        ,            R            .     ,    .         : Sys.setlocale(&quot;LC_CTYPE&quot;, &quot;ukrainian&quot;) 2.3.2                 TRUE,     FALSE,   .   :    &gt;=.  &lt;.    &lt;=.  ==.   !=        3  a, b  c. a &lt;- 12 b &lt;- 5 c &lt;- 7       . ,      /: a &gt; b ## [1] TRUE b + c &lt; a ## [1] FALSE b + c &lt;= a ## [1] TRUE ,      /: a != b ## [1] TRUE a == b + c ## [1] TRUE b == c ## [1] FALSE 2.3.3       R :  &amp; (, Shift-7) -    .  | ( , Shift+\\) -    .  ! ( , Shift+1) - .           .      : A B      A ( A) FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE FALSE TRUE FALSE TRUE TRUE TRUE TRUE FALSE     . 2.4    2.4.1   (round, ceiling, floor, trunc, signif)     ,     ,     ,     5 (3.6     4,  3.2  3,  3.5 ). !           .                 .  round() Â  .        () (   ).     (  )   &lt;0.5 &amp; &gt;=0.5 (    )   round(x, y),  x - , y -  (   /). : round(3.557, 2) ## [1] 3.56 round(3.241, 2) ## [1] 3.24 round(-3.557, 2) ## [1] -3.56 round(-3.241, 2) ## [1] -3.24    round(x)   ,      , : round(124.345) ## [1] 124  floor()           floor(): floor(3.557) ## [1] 3 floor(3.241) ## [1] 3 floor(-3.557) ## [1] -4 floor(-3.241) ## [1] -4  ceiling()           ceiling(): ceiling(3.557) ## [1] 4 ceiling(3.241) ## [1] 4 ceiling(-3.557) ## [1] -3 ceiling(-3.241) ## [1] -3  trunc()  trunc()  R      ,     x.    ,     0 (x &lt; 0) trunc()   celing(),      x &gt; 0,  floor(): x &lt;- 5.34 print(paste(&quot;trunc:&quot;, trunc(x), &quot;celing:&quot;, ceiling(x), &quot;floor:&quot;, floor(x), sep = &quot; &quot;)) ## [1] &quot;trunc: 5 celing: 6 floor: 5&quot; x &lt;- x * -1 print(paste(&quot;trunc:&quot;, trunc(x), &quot;celing:&quot;, ceiling(x), &quot;floor:&quot;, floor(x), sep = &quot; &quot;)) ## [1] &quot;trunc: -5 celing: -5 floor: -6&quot;  signif()        ,  , ,    .  ,       11 547 741.3        11.5        signif(x,y),  x - ,      , y -   (  ). : big_number &lt;- 11547741.3 rounded_big_number &lt;- signif(big_number,3) rounded_big_number ## [1] 11500000 rounded_big_number / 1000000 ## [1] 11.5 2.4.2   (seq, rep)     . 2.4.3        . runif(10) ## [1] 0.121303674 0.579740823 0.009028443 0.910000784 0.187627071 0.952063033 ## [7] 0.592665465 0.781947052 0.665769189 0.949971572 sample(100) ## [1] 1 12 60 19 81 63 58 70 99 41 25 97 96 47 55 77 16 92 ## [19] 2 61 79 69 33 100 62 8 66 37 18 5 83 85 53 38 13 65 ## [37] 11 30 57 23 40 14 87 74 45 21 4 51 27 89 20 52 10 49 ## [55] 35 39 29 75 98 68 36 7 22 24 78 84 64 59 28 17 76 93 ## [73] 71 9 56 80 15 95 6 88 73 43 3 91 26 54 90 94 31 50 ## [91] 86 32 44 46 48 34 72 82 42 67 2.4.4      R      R          , ,  .        ,          help()  ?name.     ,           .  ,  log(x)   x   e log(x,n)   x   n exp(x) e   x sqrt(x)    x factorial(x)   x abs(x)   x   R    ,       ,   cos(x), sin(x), tan(x),   acos(x), asin(x), atan(x), acosh(x), asinh(x), atanh(x).             help(function). 2.5 -      . "],["chapter3.html", " 3    R:    .  2 3.1   3.2  (vectors) 3.3 Matrices 3.4 Factors 3.5 Dataframes 3.6 Lists 3.7 Apply functions family 3.8 References", "  3    R:    .  2 :  ,   3.1       . 3.2  (vectors) 3.2.1           .     -    .      ,   -     ,      ().   ,  x = (x1, x2,, xn),   -  , n -   , 3.2.2    -     R,          c()   ,    . .    c()    .      x: x &lt;- 10    x     ,      10.         x: x &lt;- c(1, 2, 2.5, 3) x ## [1] 1.0 2.0 2.5 3.0        : numeric, character, logical : v1 &lt;- c(1, 3, 4, 6, 7) v2 &lt;- c(T, F, F, T, F) v3 &lt;- c(&quot;Hello&quot;, &quot;my&quot;, &quot;friend&quot;, &quot;!&quot;)    ,      rep(), seq()   :: vtr &lt;- 2:7 vtr ## [1] 2 3 4 5 6 7 vtr &lt;- 7:2 vtr ## [1] 7 6 5 4 3 2      ,   c(): x &lt;- 2:3 y &lt;- c(4,6,9) z &lt;- c(x, y, 10:12, 100) z ## [1] 2 3 4 6 9 10 11 12 100           summary(): summary(z) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2.00 4.00 9.00 17.44 11.00 100.00 3.2.3    The advantage of using vectors over writing each value in a separate variable is the ability to perform 1 operation on all elements of the vector or on several vectors simultaneously, for example, arithmetic operations of addition or multiplication. v1 &lt;- c(1, 3, 5) v1 ## [1] 1 3 5 v1 * 10 ## [1] 10 30 50 From the example described above, it can be understood that the addition operation is essentially a super element sum of vectors when the 1st element of the vector v1 is added to the 1st element of the \\(vector2(1 + 2)\\) and so on. Thus, the resulting vector will have the same length as the vectors \\(v1\\) and \\(v2\\). However, there may be a situation when one of the vectors has a shorter length or even consists of 1 element: v1 &lt;- c(1, 3, 5, 7) v2 &lt;- c(2, 4) v1 + v2 ## [1] 3 7 7 11 In this case, the number 2 will be added to each element of the vectorv1. In fact, this means that the vector v2 will look like c 2, 2), ie there will be a duplication of values to the length of the vectorv1 and then perform the operation of adding elements. Thus, the resulting vector will have the length of the longest of the vectors. Consider a more complex case where there are vectors with different numbers of elements other than 1: v1 &lt;- c(2, 3) v2 &lt;- c(4, 5, 6, 7) v3 &lt;- c(1, 8, 9) v1 + v2 + v3 ## Warning in v1 + v2 + v3: longer object length is not a multiple of shorter ## object length ## [1] 7 16 17 11 To begin with, it should be noted that the interpreter warns that the lengths of the vectors are not multiples (if they were vectors of length 2, 4, 8, then there would be no warning). If you extend each vector to the length of the maximum of them, repeating the elements cyclically, you get a set (marked added elements): v1 &lt;- c(2, 3,*2,*3) v2 &lt;- c(4, 5, 6, 7) v3 &lt;- c(1, 8, 9,*1) Subtraction (-), division(/) and multiplication (*) operations are performed similarly. The relation operators and logical operators also act element by element with respect to the vector, but the result is a collection (vector) of values of the logical type logical with the values TRUE/FALSE. Consider an example of finding all elements of the array \\(v1\\) that are greater than the corresponding index elements of the array \\(v2\\): v1 &lt;- c(2, 4, 7, 9, 12) v2 &lt;- c(6, 4, 6, 7, 1) v1 &gt; v2 ## [1] FALSE FALSE TRUE TRUE TRUE In essence, as a result of execution there is a comparison of each element of both vectors among themselves: 2&gt;6, 4&gt;4, 7&gt;6, 9&gt;7, 12&gt;1. Therefore, the previously studied operators (arithmetic, logical, relations) can be used to work with vectors as well. 3.2.4 Naming vector elements In order to understand what vectors mean and what data is often described, analysts need to sign this data. We will write down information about daily visits to the site by users during the week in the following way: # Count of unique bank branch visits from Monday to Sunday data &lt;- c(1245, 2112, 1321, 1231, 2342, 1718, 1980) Next, assign values to the days of the week using the names() function: names(data) &lt;- c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;) print(data) ## Monday Tuesday Wednesday Thursday Friday Saturday Sunday ## 1245 2112 1321 1231 2342 1718 1980 Otherwise, this code could be written as follows: data &lt;- c(1245, 2112, 1321, 1231, 2342, 1718, 1980) days &lt;- c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;) names(data) &lt;- days data ## Monday Tuesday Wednesday Thursday Friday Saturday Sunday ## 1245 2112 1321 1231 2342 1718 1980 If we need to get information, for example, about the name of the 4th element of the vector, we can use the code: names(data) ## [1] &quot;Monday&quot; &quot;Tuesday&quot; &quot;Wednesday&quot; &quot;Thursday&quot; &quot;Friday&quot; &quot;Saturday&quot; ## [7] &quot;Sunday&quot; The names() function allows not only to set the values of names for vector elements, but also to obtain information about them. 3.2.5 Access to vector elements Indexing of elements inside the wind occurs from 1 ton, where n is the number of elements of the vector. Note. In R, the indexing of array, vector, and all other collection types begins with 1, not with 0. Consider the previous example: data &lt;- c(1245, 2112, 1321, 1231, 2342, 1718, 1980) days &lt;- c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;) names(data) &lt;- days In order to record information only about site visitors on Wednesday, you need to use the operator [] and specify the index of the element in the array: data[3] ## Wednesday ## 1321 data[names(data) == &#39;Wednesday&#39;] ## Wednesday ## 1321 If there is a need to get several elements of the vector that are out of order, you can do it like this: some_days &lt;- data[c(1, 2, 5)] some_days ## Monday Tuesday Friday ## 1245 2112 2342 From the example above it is clear that the indices of the vector data are another vector c(1, 2, 5), so it can be declared as a separate variable: indexes &lt;- c(1, 2, 5) some_days &lt;- data[indexes] some_days ## Monday Tuesday Friday ## 1245 2112 2342 If there is a need to obtain information about several elements that are placed in a row, then for convenience (and in the case when such an array consists, for example, of 1000+ elements) use the operator :, for example: working_days &lt;- data[1:5] working_days ## Monday Tuesday Wednesday Thursday Friday ## 1245 2112 1321 1231 2342 Thus, all working days of the week are selected for the working_days vector. 3.2.6 Useful functions Lets take a look at some useful features that will simplify working with vectors. For further calculations we will use two vectors A andB: A &lt;- c(3, 5, 8, 2, 5, 4, 2) B &lt;- c(3, NA, 1, NA, 6, 4, 5) A ## [1] 3 5 8 2 5 4 2 B ## [1] 3 NA 1 NA 6 4 5 Function sum(). This function is used to find the sum of the elements of the collection: sum(A) ## [1] 29 sum(B) ## [1] NA An interesting point is that in the presence of gaps in the data (value NA) the calculation of the amount is impossible. In this case, the functions can take the additional parameter na.rm = T, whereT is an abbreviation of TRUE, which indicates the need to remove gaps in the data before performing the operation Note. You should check the documentation for such a parameter in the function. If it is not present, then it is necessary to carry out cleaning in other ways before work with the data. sum(B, na.rm = T) ## [1] 19 The mean () function is used to find the arithmetic mean of numbers: mean(A) ## [1] 4.142857 mean(B, na.rm = T) ## [1] 3.8 min() and max() functions allow you to find the minimum and maximum values, respectively: min(A) ## [1] 2 max(A) ## [1] 8 Also to work in R there is a large number of built-in implemented functions to perform statistical, econometric and other research in the field of economics and beyond. Try the sd(), cov(), cor() functions. The length () function helps to determine the length of a vector, ie the number of elements: length(A) ## [1] 7 length(B) ## [1] 7 The unique () function identifies unique elements in an array: A ## [1] 3 5 8 2 5 4 2 unique(A) ## [1] 3 5 8 2 4 print(&quot;---&quot;) ## [1] &quot;---&quot; B ## [1] 3 NA 1 NA 6 4 5 unique(B) ## [1] 3 NA 1 6 4 5 The intersect() function allows you to find common elements of two vectors, so for vectors A andB common values are 3, 4 and5: A ## [1] 3 5 8 2 5 4 2 B ## [1] 3 NA 1 NA 6 4 5 intersect(A, B) ## [1] 3 5 4 Conversely, The union() function allows you to combine elements of both sets / vectors: A ## [1] 3 5 8 2 5 4 2 B ## [1] 3 NA 1 NA 6 4 5 union(A, B) ## [1] 3 5 8 2 4 NA 1 6 Try to understand the operation of the functions setdiff(), setequal(), is.element(). _I recommend reading the short materials here: https://stat.ethz.ch/R-manual/R-devel/library/base/html/sets.html._ 3.2.7 Correction of data (NA, NaN, Inf) In the process of working with data there are problems associated with the correctness of their reading, conversion and operations on them. For example, an incorrect entry in the field of integer type \" +10 \" instead of 10 may result in conversion toNaN or division by 0 toInf. Before using numerical and other data, the stage of cleaning and replacement of values is usually performed depending on the tasks of programming / research. In R the following types of the missed values are possible: NA ** - Not Available. NaN ** - Not a Number. Inf ** - Infinity (infinity, can be with the sign+and-). Lets start with vector: vtr &lt;- c(1, -2, NA, NaN, Inf, 1223, -Inf, NA, 21) vtr ## [1] 1 -2 NA NaN Inf 1223 -Inf NA 21 You can check a single value for a space with the functions is.na(), is.nan(), is.infinite(), is.finite(). is.na(vtr) ## [1] FALSE FALSE TRUE TRUE FALSE FALSE FALSE TRUE FALSE is.nan(vtr) ## [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE is.infinite(vtr) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE is.finite(vtr) # if infinite == TRUE =&gt; finite == FALSE :) ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE Then replacement of values can be executed as follows (we will replace all NA and Nan with 1000): vtr[is.na(vtr)] &lt;- 1000 vtr ## [1] 1 -2 1000 1000 Inf 1223 -Inf 1000 21 ## Nan also replaced with is.na()!!! And then replace Inf with the maximum value in the vector, and -Inf with the minimum: vtr[is.nan(vtr)] &lt;- 500 vtr ## [1] 1 -2 1000 1000 Inf 1223 -Inf 1000 21 vtr[is.na(vtr)] &lt;- 1000 vtr ## [1] 1 -2 1000 1000 Inf 1223 -Inf 1000 21 ## Nan also replaced with is.na()!!! And then replace Inf with the maximum value in the vector, and -Inf with the minimum: vtr &lt;- c(1, -2, NA, NaN, Inf, 1223, -Inf, NA, 21) vtr ## [1] 1 -2 NA NaN Inf 1223 -Inf NA 21 is.infinite(vtr) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE !is.infinite(vtr) ## [1] TRUE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE vtr[!is.infinite(vtr)] ## [1] 1 -2 NA NaN 1223 NA 21 max(vtr[!is.infinite(vtr)], na.rm = T) ## [1] 1223 max(vtr, na.rm = T) ## [1] Inf min(vtr, na.rm = T) ## [1] -Inf vtr[vtr == Inf] &lt;- max(vtr) vtr[vtr == -Inf] &lt;- min(vtr) vtr ## [1] 1 -2 NA NaN NA 1223 NA NA 21 If you want to replace the value in Inf regardless of the sign, you can useis.infinite(). 3.2.8 Tasks Task 1 Create vector of 10 random number in range \\([10;100]\\) Replace all odd numbers with NA Replace all NA with average value Solution x &lt;- sample(1:100, size = 10) x ## [1] 79 91 23 45 56 84 31 28 42 68 x[x %% 2 != 0] &lt;- NA x ## [1] NA NA NA NA 56 84 NA 28 42 68 x[is.na(x)] &lt;- mean(x, na.rm = T) x ## [1] 55.6 55.6 55.6 55.6 56.0 84.0 55.6 28.0 42.0 68.0 3.3 Matrices 3.3.1 Creating matrices Matrix - a collection of elements of the same type (numeric,character, logical) with a fixed set of rows and columns. In the case where the matrix has only rows and columns, it is a two-dimensional data array. The matrix is created using the matrix() function: matrix(1:10, byrow = TRUE, nrow = 2) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 where 1:10 - a set of elements of the matrix, it can also be a pre-formed vector (entered, by calculation, from a file, etc.), byrow = TRUE - means that the elements in the matrix will be written in rows, so in the pedestrian line contains the value 1:5, and the second 6:10 (if we need to write information on the lines then we should use byrow = FASLE), nrow - the number of rows of the matrix. sales1 &lt;- c(12, 14, 15) sales2 &lt;- c(22, 15, 21) sales &lt;- c(sales1, sales2) m &lt;- matrix(sales, byrow= T, nrow = 2) m ## [,1] [,2] [,3] ## [1,] 12 14 15 ## [2,] 22 15 21 3.3.2 Naming matrices To specify the names of rows and columns of the matrix, use the functions rownames() and colnames(): m &lt;- matrix(1:9, nrow = 3) rownames(m) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;) colnames(m) &lt;- c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;) m ## c1 c2 c3 ## row1 1 4 7 ## row2 2 5 8 ## row3 3 6 9 Add rows and columns Special methods cbind/rbind are used to change the number of elements in rows and columns of matrices, as well as to quickly combine them. The cbind function allows you to add one or more matrices and/or vectors behind one of the columns. That is, there is not a simple connection, but a comparison by key field. Consider an example: m1 &lt;- matrix(c(1:3, 101:103), nrow = 3) colnames(m1) &lt;- c(&quot;A&quot;, &quot;B&quot;) m2 &lt;- matrix(c(201:203, 1001:1003), nrow = 3) colnames(m2) &lt;- c(&quot;C&quot;, &quot;D&quot;) m_bind &lt;- cbind(m1, m2) m1 ## A B ## [1,] 1 101 ## [2,] 2 102 ## [3,] 3 103 m2 ## C D ## [1,] 201 1001 ## [2,] 202 1002 ## [3,] 203 1003 m_bind ## A B C D ## [1,] 1 101 201 1001 ## [2,] 2 102 202 1002 ## [3,] 3 103 203 1003 3.3.3 Access to matrix elements The elements of the matrix are accessed by the index of rows and columns. You can select ranges in a similar way to vectors. Lets look at an example: m &lt;- matrix(11:25, nrow = 3) m ## [,1] [,2] [,3] [,4] [,5] ## [1,] 11 14 17 20 23 ## [2,] 12 15 18 21 24 ## [3,] 13 16 19 22 25 To display the 10th element of the matrix, you can use the entries (note that the account is from the right left corner of the columns): m[10] ## [1] 20 m[[10]] ## [1] 20 To display the same element using row and column indexes, write as follows: # Row #1 # Column #4 m[1,4] ## [1] 20 Question: What record should you use ti get 18? Answer: m[2,3] m[2,3] ## [1] 18 If you want to output / use an entire row or a whole column, then the block with the index of unnecessary dimensionality can be left blank: m[1, ] # first row only ## [1] 11 14 17 20 23 m[c(1,3), ] # first and third row only ## [,1] [,2] [,3] [,4] [,5] ## [1,] 11 14 17 20 23 ## [2,] 13 16 19 22 25 m[, 1] # first column only ## [1] 11 12 13 m[, c(1,3)] # first and third column only ## [,1] [,2] ## [1,] 11 17 ## [2,] 12 18 ## [3,] 13 19 You can also specify a list of rows and columns to be output / received simultaneously: m[c(1,3), 2:4] ## [,1] [,2] [,3] ## [1,] 14 17 20 ## [2,] 16 19 22 You can exclude individual columns or rows by using indexes with minus signs (-): m[-1, c(-2:-3)] ## [,1] [,2] [,3] ## [1,] 12 21 24 ## [2,] 13 22 25 3.3.4 Useful functions Matrix dimmentions To obtain information about the dimensions of the table, there are special functions: nrow(), ncol(), dim(): # Decalre matrix m &lt;- matrix(1:15, ncol = 3) m ## [,1] [,2] [,3] ## [1,] 1 6 11 ## [2,] 2 7 12 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 print(paste(&quot;Rows:&quot;, nrow(m))) ## [1] &quot;Rows: 5&quot; print(paste(&quot;Cols:&quot;, ncol(m))) ## [1] &quot;Cols: 3&quot; print(paste(&quot;Dim:&quot;, paste0(dim(m), collapse = &quot; x &quot;))) ## [1] &quot;Dim: 5 x 3&quot; Using nrow() andncol() allows you to access the last row and column of the matrix, respectively: m[nrow(m), ] # last row ## [1] 5 10 15 m[, ncol(m)] # last colum ## [1] 11 12 13 14 15 3.4 Factors Factors in R programming allow you to represent a vector of values as categorical values, rather than just a set of text data or numbers. The advantage of the categorical data type is that the element can take only a limited number of values, and not any value that allows the data type. For example, a numeric vector may contain an infinitely large variation of the values c(1, 0.021, 192.1444, , etc.), the character sets may also be different c (sdf &amp; Tg6,sdf * Y &amp; 65). The number of combinations of such vectors is very large. In the case of categories, we are talking about certain fixed values. A good example is forms that are filled out on sites with drop-down lists, where the user cannot enter a value, but only select from an existing list. So in the gender field there is usually a limited set of possible options: Male,Female, Other. The user can select only one of these values and does not have the ability to enter something else (this is an example, each resource can make different forms for users). Creation of factors in R occurs by means of function factor(): gender &lt;- c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) gender ## [1] &quot;Male&quot; &quot;Female&quot; &quot;Other&quot; &quot;Male&quot; &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; gender_factor &lt;- factor(gender) gender_factor ## [1] Male Female Other Male Female Male Female Female ## Levels: Female Male Other When creating a factor, each unique element gets its own digital? (from the outside it looks like this, it needs to be clarified) value inside the collection, this value is called the level (level). In the previous example, the variable gender _factor received the levels Female, Male, Other in alphabetical order. If we convert factors to numbers, we get: as.numeric(gender_factor) ## [1] 2 1 3 2 1 2 1 1 gender Thus it is clear that Female = 1, Male = 2, Other = 3. Consider a situation where we get data in which the order of values in the factor collection is different, for example, we need to specify so that Male = 1, Female = 2, Other = 3: gender &lt;- c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) gender_factor &lt;- factor(gender, levels = c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;)) gender_factor ## [1] Male Female Other Male Female Male Female Female ## Levels: Male Female Other lvl &lt;- levels(gender_factor) # read levels of factor seq_along(lvl) ## [1] 1 2 3 as.integer(lvl) ## Warning: NAs introduced by coercion ## [1] NA NA NA as.numeric(gender_factor) ## [1] 1 2 3 1 2 1 2 2 Now the order of the levels corresponds to ours and this will allow us to successfully combine our collection with similar ones that have the same set of values. Sometimes it is necessary to change not only the order of the elements in the factorial collection, but also their names. Lets consider a situation when we need to rename values Male,Female, Other inM, F,O: gender &lt;- c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) gender_factor &lt;- factor(gender, levels = c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;)) levels(gender_factor) &lt;- c(&quot;M&quot;, &quot;F&quot;, &quot;O&quot;) gender_factor ## [1] M F O M F M F F ## Levels: M F O But you should check you type with is.factor() before converting to numbers: cities &lt;- c(&quot;Rivne&quot;, &quot;Ostroh&quot;, &quot;Zdolbuniv&quot;, &quot;Dubno&quot;, &quot;Sarny&quot;) cities_as_factors &lt;- factor(cities) as.numeric(cities_as_factors) ## [1] 3 2 5 1 4 as.numeric(cities) # you cannot convert characters vector to numerics ## Warning: NAs introduced by coercion ## [1] NA NA NA NA NA 3.5 Dataframes Data frames are the most popular data structure in R, becouse it allows collect data with different columns type in one object and quickly manipulate it. A data frame, a matrix-like structure whose columns may be of differing types (numeric, logical, factor and character and so on). The function data.frame() creates data frames, tightly coupled collections of variables which share many of the properties of matrices and of lists, used as the fundamental data structure by most of Rs modeling software. Syntax {r} data.frame(, row.names = NULL, check.rows = FALSE, check.names = TRUE, fix.empty.names = TRUE, stringsAsFactors = FALSE) Arguments (top useful)  - these arguments are of either the form value or tag = value. Component names are created based on the tag (if present) or the deparsed argument itself. row.names - NULL or a single integer or character string specifying a column to be used as row names, or a character or integer vector giving the row names for the data frame. stringsAsFactors - logical: should character vectors be converted to factors? The factory-fresh default has been TRUE previously but has been changed to FALSE Details A data frame is a list of variables of the same number of rows with unique row names, given class data.frame. If no variables are included, the row names determine the number of rows. data.frame converts each of its arguments to a data frame by calling as.data.frame(optional = TRUE). As that is a generic function, methods can be written to change the behaviour of arguments according to their classes: R comes with many such methods. Character variables passed to data.frame are converted to factor columns unless protected argument stringsAsFactors is false. If a list or data frame or matrix is passed to data.frame it is as if each component or column had been passed as a separate argument. 3.5.1 Creating Data Frames Data frames are usually created by reading in a dataset from file, scraping from websites. However, data frames can also be created explicitly with the data.frame() function or they can be coerced from other types of objects like lists. In this case Ill create a simple data frame df and assess its basic structure: df &lt;- data.frame(id = 1:5, char_col = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;), log_col = c(T,T,T,F,T), double_col = c(2.1, 1, 0.5, pi, 12.7)) df ## id char_col log_col double_col ## 1 1 a TRUE 2.100000 ## 2 2 b TRUE 1.000000 ## 3 3 c TRUE 0.500000 ## 4 4 d FALSE 3.141593 ## 5 5 e TRUE 12.700000 # assess the structure of a data frame str(df) ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ id : int 1 2 3 4 5 ## $ char_col : chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ log_col : logi TRUE TRUE TRUE FALSE TRUE ## $ double_col: num 2.1 1 0.5 3.14 12.7 # number of rows nrow(df) ## [1] 5 # number of columns ncol(df) ## [1] 4 df &lt;- data.frame(i = 1:5, char_col = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;), log_col = c(T,T,T,F,T), double_col = c(2.1, 1, 0.5, pi, 12.7), stringsAsFactors = TRUE) # warning it depends on local settings of R df ## i char_col log_col double_col ## 1 1 a TRUE 2.100000 ## 2 2 b TRUE 1.000000 ## 3 3 c TRUE 0.500000 ## 4 4 d FALSE 3.141593 ## 5 5 e TRUE 12.700000 Creating data.frames from lists (P.S. lists explained in next chapter): demo_list &lt;- list(int_col = v_int, char_col = v_char, log_col = v_log, double_col = v_double) as.data.frame(demo_list) Matrix can be base for data frame too: demo_matrix &lt;- matrix(100:119, nrow = 5, ncol = 4) demo_matrix ## [,1] [,2] [,3] [,4] ## [1,] 100 105 110 115 ## [2,] 101 106 111 116 ## [3,] 102 107 112 117 ## [4,] 103 108 113 118 ## [5,] 104 109 114 119 as.data.frame(demo_matrix) ## V1 V2 V3 V4 ## 1 100 105 110 115 ## 2 101 106 111 116 ## 3 102 107 112 117 ## 4 103 108 113 118 ## 5 104 109 114 119 3.5.2 Extending data frames You can add rows and columns to data frame. Merging two data frames by selected column values awailable too. cbind() adds new column df &lt;- data.frame(A1 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), A2 = c(&quot;D&quot;, &quot;E&quot;, &quot;F&quot;)) df ## A1 A2 ## 1 A D ## 2 B E ## 3 C F A3 = c(1, 2, 3) cbind(df, A3) ## A1 A2 A3 ## 1 A D 1 ## 2 B E 2 ## 3 C F 3 colnames(df) ## [1] &quot;A1&quot; &quot;A2&quot; colnames(df) &lt;- c(&quot;B1&quot;, &quot;B2&quot;) colnames(df) ## [1] &quot;B1&quot; &quot;B2&quot; rbind() adds new row letters_frame &lt;- data.frame(A1 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), A2 = 1:3) letters_frame ## A1 A2 ## 1 A 1 ## 2 B 2 ## 3 C 3 next_row = c(&quot;D&quot;, 4) # data types by row should be the same as in initial data frame rbind(letters_frame, next_row) ## A1 A2 ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 3.5.3 Merge DF Data frames could me merged by key with merge(): df1 &lt;- data.frame(Id = c(1:4), Name = c(&quot;Nick&quot;, &quot;Jake&quot;, &quot;Jane&quot;, &quot;Mary&quot;)) df1 ## Id Name ## 1 1 Nick ## 2 2 Jake ## 3 3 Jane ## 4 4 Mary df2 &lt;- data.frame(Id = c(2, 1, 3, 5), # defferent order from Id in df1 Age = c(34, 21, 45, 20)) df2 ## Id Age ## 1 2 34 ## 2 1 21 ## 3 3 45 ## 4 5 20 df_final &lt;- merge(df1, df2, by = &quot;Id&quot;, all.x = F, all.y = F) df_final ## Id Name Age ## 1 1 Nick 21 ## 2 2 Jake 34 ## 3 3 Jane 45 3.5.4 Subsetting Data Frames Data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists and will return the selected columns with all rows; if you subset with two vectors, they behave like matrices and can be subset by row and column: df &lt;- data.frame(int_col = 1:5, char_col = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;), log_col = c(T,T,T,F,T), double_col = c(2.1, 1, 0.5, pi, 12.7), row.names = paste0(&quot;row_&quot;, 1:5), # setting row names stringsAsFactors = TRUE) # warning it depends on local settings of R df ## int_col char_col log_col double_col ## row_1 1 a TRUE 2.100000 ## row_2 2 b TRUE 1.000000 ## row_3 3 c TRUE 0.500000 ## row_4 4 d FALSE 3.141593 ## row_5 5 e TRUE 12.700000 # select columns using $ sign df$log_col ## [1] TRUE TRUE TRUE FALSE TRUE # subsetting by row numbers df[1, ] # first row ## int_col char_col log_col double_col ## row_1 1 a TRUE 2.1 df[nrow(df), ] # last row ## int_col char_col log_col double_col ## row_5 5 e TRUE 12.7 df[-1, ] # all except first row ## int_col char_col log_col double_col ## row_2 2 b TRUE 1.000000 ## row_3 3 c TRUE 0.500000 ## row_4 4 d FALSE 3.141593 ## row_5 5 e TRUE 12.700000 # subsetting by row names df[c(&quot;row_4&quot;, &quot;row_5&quot;), ] ## int_col char_col log_col double_col ## row_4 4 d FALSE 3.141593 ## row_5 5 e TRUE 12.700000 # subsetting columns like a list df[, c(&quot;log_col&quot;, &quot;double_col&quot;)] ## log_col double_col ## row_1 TRUE 2.100000 ## row_2 TRUE 1.000000 ## row_3 TRUE 0.500000 ## row_4 FALSE 3.141593 ## row_5 TRUE 12.700000 # subset for both rows and columns df[2:5, c(1, 3:4)] ## int_col log_col double_col ## row_2 2 TRUE 1.000000 ## row_3 3 TRUE 0.500000 ## row_4 4 FALSE 3.141593 ## row_5 5 TRUE 12.700000 # select only with log_col == TRUE df[df$double_col &gt; 1, ] ## int_col char_col log_col double_col ## row_1 1 a TRUE 2.100000 ## row_4 4 d FALSE 3.141593 ## row_5 5 e TRUE 12.700000 df[!df$log_col, ] ## int_col char_col log_col double_col ## row_4 4 d FALSE 3.141593 &quot;s&quot; %in% c(&quot;s&quot;, &quot;t&quot;) ## [1] TRUE # select only with char_col == &#39;a&#39;, &#39;e&#39; chars &lt;- df$char_col %in% c(&quot;a&quot;, &quot;e&quot;) chars ## [1] TRUE FALSE FALSE FALSE TRUE sum(chars) ## [1] 2 df[chars, ] # %in% operator for check multuiple values ## int_col char_col log_col double_col ## row_1 1 a TRUE 2.1 ## row_5 5 e TRUE 12.7 # select only with double_col &gt; 1 and log_col == TRUE df[df$log_col == TRUE &amp; df$double_col &gt; 1, ] ## int_col char_col log_col double_col ## row_1 1 a TRUE 2.1 ## row_5 5 e TRUE 12.7 # select only specific columns with double_col &gt; 1 and log_col == TRUE df[df$log_col == TRUE &amp; df$double_col &gt; 1, c(&quot;log_col&quot;, &quot;int_col&quot;, &quot;double_col&quot;)] ## log_col int_col double_col ## row_1 TRUE 1 2.1 ## row_5 TRUE 5 12.7 3.5.5 Order data.frame Lets use our previous sample data.frame but with unordered values: df &lt;- data.frame(int_col = c(1, 5, 3, 4, 2), char_col = c(&quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;d&quot;, &quot;e&quot;), log_col = c(T,T,T,F,T), double_col = c(2.1, 1, 0.5, pi, 12.7), row.names = paste0(&quot;row_&quot;, 1:5), # setting row names stringsAsFactors = TRUE) # warning it depends on local settings of R df ## int_col char_col log_col double_col ## row_1 1 b TRUE 2.100000 ## row_2 5 a TRUE 1.000000 ## row_3 3 a TRUE 0.500000 ## row_4 4 d FALSE 3.141593 ## row_5 2 e TRUE 12.700000 You can use order() function for sorting data.frames. # sort by int_col order(df$char_col) ## [1] 2 3 1 4 5 order(df$int_col) ## [1] 1 5 3 4 2 df[order(df$char_col),] ## int_col char_col log_col double_col ## row_2 5 a TRUE 1.000000 ## row_3 3 a TRUE 0.500000 ## row_1 1 b TRUE 2.100000 ## row_4 4 d FALSE 3.141593 ## row_5 2 e TRUE 12.700000 Use - minus to sort descending # sort by double_col # rev df[rev(order(df$int_col)), ] ## int_col char_col log_col double_col ## row_2 5 a TRUE 1.000000 ## row_4 4 d FALSE 3.141593 ## row_3 3 a TRUE 0.500000 ## row_5 2 e TRUE 12.700000 ## row_1 1 b TRUE 2.100000 You can also sor by multiple columns with order(column1, column2) or order(column1, -column2). 3.5.6 Manipulating data.frames 3.5.7 Tasks on data.frames Task 1 Write a code evaluates $y = x^2 + e, where x is a random number in range [0; 1]. Print calculation result as data.frame with columns X, E, Y. Use plot() funtion to visualize X vs Y as line chart (type = l or b). Solution # initiate data.frame df &lt;- data.frame(X = 1:10, E = sample(5, 10, replace = T), Y = NA) head(df) ## X E Y ## 1 1 3 NA ## 2 2 4 NA ## 3 3 2 NA ## 4 4 2 NA ## 5 5 3 NA ## 6 6 1 NA df$Y &lt;- with(df, X^2 + E) head(df) ## X E Y ## 1 1 3 4 ## 2 2 4 8 ## 3 3 2 11 ## 4 4 2 18 ## 5 5 3 28 ## 6 6 1 37 plot(df$X, df$Y, type=&quot;l&quot;, col = &quot;blue&quot;) Task 2 Install package and load package ISLR Save dataset Credit into variable credit_data. Check dataset structure with str() function. Convert Student status yes/no to 1/0 Order dataset by Rating descending Filter only Age &gt; 50 with Rating &gt; 400, how many records do you get? Evaluate average Income for Married = YES Married = NO with Age in range [20,30] 7.1 Make the same for Age [30;40] Any conclusion? Solution # 1. install.package ISLR #install.packages(&quot;ISLR&quot;) library(ISLR) # 2. Save dataset `Credit` into variable `credit_data`. credit_data &lt;- ISLR::Credit head(credit_data, 3) ## ID Income Limit Rating Cards Age Education Gender Student Married Ethnicity ## 1 1 14.891 3606 283 2 34 11 Male No Yes Caucasian ## 2 2 106.025 6645 483 3 82 15 Female Yes Yes Asian ## 3 3 104.593 7075 514 4 71 11 Male No No Asian ## Balance ## 1 333 ## 2 903 ## 3 580 # 3. Check dataset structure with `str()` function. str(credit_data) ## &#39;data.frame&#39;: 400 obs. of 12 variables: ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Income : num 14.9 106 104.6 148.9 55.9 ... ## $ Limit : int 3606 6645 7075 9504 4897 8047 3388 7114 3300 6819 ... ## $ Rating : int 283 483 514 681 357 569 259 512 266 491 ... ## $ Cards : int 2 3 4 3 2 4 2 2 5 3 ... ## $ Age : int 34 82 71 36 68 77 37 87 66 41 ... ## $ Education: int 11 15 11 11 16 10 12 9 13 19 ... ## $ Gender : Factor w/ 2 levels &quot; Male&quot;,&quot;Female&quot;: 1 2 1 2 1 1 2 1 2 2 ... ## $ Student : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 1 2 1 1 1 1 1 1 1 2 ... ## $ Married : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 1 1 2 1 1 1 1 2 ... ## $ Ethnicity: Factor w/ 3 levels &quot;African American&quot;,..: 3 2 2 2 3 3 1 2 3 1 ... ## $ Balance : int 333 903 580 964 331 1151 203 872 279 1350 ... # Convert Student status &quot;yes/no&quot; to 1/0 as.numeric(credit_data$Student) - 1 ## [1] 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 ## [38] 0 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [75] 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 ## [112] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ## [149] 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [186] 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 ## [223] 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 ## [260] 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [297] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 ## [334] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 ## [371] 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 credit_data$Student &lt;- as.character(credit_data$Student) # convert to character first / factors credit_data$Student &lt;- ifelse(credit_data$Student == &quot;Yes&quot;, 1, 0) head(credit_data) ## ID Income Limit Rating Cards Age Education Gender Student Married Ethnicity ## 1 1 14.891 3606 283 2 34 11 Male 0 Yes Caucasian ## 2 2 106.025 6645 483 3 82 15 Female 1 Yes Asian ## 3 3 104.593 7075 514 4 71 11 Male 0 No Asian ## 4 4 148.924 9504 681 3 36 11 Female 0 No Asian ## 5 5 55.882 4897 357 2 68 16 Male 0 Yes Caucasian ## 6 6 80.180 8047 569 4 77 10 Male 0 No Caucasian ## Balance ## 1 333 ## 2 903 ## 3 580 ## 4 964 ## 5 331 ## 6 1151 # 5. Order dataset by `Rating` descending credit_data &lt;- credit_data[order(-credit_data$Rating), ] head(credit_data) ## ID Income Limit Rating Cards Age Education Gender Student Married ## 324 324 182.728 13913 982 4 98 17 Male 0 Yes ## 29 29 186.634 13414 949 2 41 14 Female 0 Yes ## 356 356 180.682 11966 832 2 58 8 Female 0 Yes ## 86 86 152.298 12066 828 4 41 12 Female 0 Yes ## 294 294 140.672 11200 817 7 46 9 Male 0 Yes ## 185 185 158.889 11589 805 1 62 17 Female 0 Yes ## Ethnicity Balance ## 324 Caucasian 1999 ## 29 African American 1809 ## 356 African American 1405 ## 86 Asian 1779 ## 294 African American 1677 ## 185 Caucasian 1448 # 6. Filter only `Age &gt; 50` with `Rating &gt; 400` credict_data_filtered &lt;- credit_data[credit_data$Age &gt; 50 &amp; credit_data$Rating &gt; 400, ] head(credict_data_filtered) ## ID Income Limit Rating Cards Age Education Gender Student Married ## 324 324 182.728 13913 982 4 98 17 Male 0 Yes ## 356 356 180.682 11966 832 2 58 8 Female 0 Yes ## 185 185 158.889 11589 805 1 62 17 Female 0 Yes ## 348 348 160.231 10748 754 2 69 17 Male 0 No ## 175 175 121.834 10673 750 3 54 16 Male 0 No ## 391 391 135.118 10578 747 3 81 15 Female 0 Yes ## Ethnicity Balance ## 324 Caucasian 1999 ## 356 African American 1405 ## 185 Caucasian 1448 ## 348 Caucasian 1192 ## 175 African American 1573 ## 391 Asian 1393 nrow(credict_data_filtered) ## [1] 73 #7. Evaluate average `Income` for `Married = YES` `Married = NO` with age in rage [20,30] # 7.1 Make the same for Age [30;40] married &lt;- with(credit_data, credit_data[(Age&gt;=20 &amp; Age &lt;=30) &amp; Married == &quot;Yes&quot;, ]) head(married) ## ID Income Limit Rating Cards Age Education Gender Student Married ## 11 11 63.095 8117 589 4 30 14 Male 0 Yes ## 114 114 69.251 6386 474 4 30 12 Female 0 Yes ## 45 45 31.861 6375 469 3 25 16 Female 0 Yes ## 19 19 49.570 6384 448 1 28 9 Female 0 Yes ## 44 44 36.929 6257 445 1 24 14 Female 0 Yes ## 151 151 63.931 5728 435 3 28 14 Female 0 Yes ## Ethnicity Balance ## 11 Caucasian 1407 ## 114 Asian 768 ## 45 Caucasian 1120 ## 19 Asian 891 ## 44 Asian 976 ## 151 African American 581 not_married &lt;- credit_data[credit_data$Age %in% c(20:30) &amp; credit_data$Married == &quot;No&quot;, ] head(not_married) ## ID Income Limit Rating Cards Age Education Gender Student Married ## 212 212 29.567 5309 397 3 25 15 Male 0 No ## 94 94 16.479 5435 388 2 26 16 Male 0 No ## 272 272 44.978 4866 347 1 30 10 Female 0 No ## 206 206 10.793 3878 321 8 29 13 Male 0 No ## 179 179 28.316 4391 316 2 29 10 Female 0 No ## 186 186 30.420 4442 316 1 30 14 Female 0 No ## Ethnicity Balance ## 212 Caucasian 799 ## 94 African American 937 ## 272 Caucasian 436 ## 206 Caucasian 638 ## 179 Caucasian 453 ## 186 African American 450 mean(married$Income) # is it better to be merried? :) ## [1] 35.25635 mean(not_married$Income) ## [1] 25.16183 3.6 Lists Lists are the R objects which contain elements of different types like  numbers, strings, vectors and another list inside it. A list can also contain a matrix or a function as its elements. List is created using list() function. Before start lest see one more package for working with date lubridate. It has a lot of functions for date parsing, manipulating and other. Check it with: #install.packages(&quot;lubridate&quot;) ??lubridate ## starting httpd help server ... done For our sample we need function ymd() that parse charater date from format like 2012-10-25. library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union date1 &lt;- ymd(&quot;2021-05-25&quot;) date2 &lt;- ymd(&quot;2021-05-27&quot;) date1 ## [1] &quot;2021-05-25&quot; date2 ## [1] &quot;2021-05-27&quot; You can also use ymdhms() to parse date and time correctly. datetime &lt;- ymd_hms(&quot;2021-05-25 11:05:12&quot;, tz = &quot;UTC&quot;) # wee need this for client transactions fix datetime ## [1] &quot;2021-05-25 11:05:12 UTC&quot; 3.6.1 Creating a List Following is an example to create a list containing vectors, strings, numbers and a logical values. Our list will describe a model of banks client: # initial values set.seed(1) # for fixing pseudo-random client_name &lt;- &quot;John Doe&quot; services &lt;- c(&quot;credit&quot;, &quot;deposite&quot;, &quot;online-app&quot;) is_active &lt;- TRUE transactions &lt;- data.frame(contract_id = sample(10000:99999, size = 2, replace = T),# random numbers datetime = c(ymd_hms(&quot;2021-05-25 11:05:12&quot;), ymd_hms(&quot;2021-05-25 11:07:14&quot;), ymd_hms(&quot;2021-05-25 11:08:02&quot;), ymd_hms(&quot;2021-05-25 11:12:45&quot;), ymd_hms(&quot;2021-05-25 11:47:00&quot;), ymd_hms(&quot;2021-05-25 11:48:08&quot;)), oper_type = sample(0:1, size=6, replace = T), # 1 for debet, 0 for credet amount = round(sample(1:1000, size = 6) + runif(6),2)) #change AMOUNT to minus for debet (opertype == 1 transactions$amount &lt;- ifelse(transactions$oper_type == 1, (-1)*transactions$amount, transactions$amount) transactions ## contract_id datetime oper_type amount ## 1 34387 2021-05-25 11:05:12 1 -187.72 ## 2 69520 2021-05-25 11:07:14 0 307.99 ## 3 34387 2021-05-25 11:08:02 0 993.38 ## 4 69520 2021-05-25 11:12:45 0 597.78 ## 5 34387 2021-05-25 11:47:00 1 -277.93 ## 6 69520 2021-05-25 11:48:08 1 -874.21 # creating list of signle objects, vector and dataframe list_data &lt;- list(client_name, is_active, services, transactions) list_data ## [[1]] ## [1] &quot;John Doe&quot; ## ## [[2]] ## [1] TRUE ## ## [[3]] ## [1] &quot;credit&quot; &quot;deposite&quot; &quot;online-app&quot; ## ## [[4]] ## contract_id datetime oper_type amount ## 1 34387 2021-05-25 11:05:12 1 -187.72 ## 2 69520 2021-05-25 11:07:14 0 307.99 ## 3 34387 2021-05-25 11:08:02 0 993.38 ## 4 69520 2021-05-25 11:12:45 0 597.78 ## 5 34387 2021-05-25 11:47:00 1 -277.93 ## 6 69520 2021-05-25 11:48:08 1 -874.21 3.6.2 Naming List Elements Its better to name elements in list: names(list_data) &lt;- c(&quot;ClientName&quot;, &quot;IsActive&quot;, &quot;Services&quot;, &quot;Transactions&quot;) list_data ## $ClientName ## [1] &quot;John Doe&quot; ## ## $IsActive ## [1] TRUE ## ## $Services ## [1] &quot;credit&quot; &quot;deposite&quot; &quot;online-app&quot; ## ## $Transactions ## contract_id datetime oper_type amount ## 1 34387 2021-05-25 11:05:12 1 -187.72 ## 2 69520 2021-05-25 11:07:14 0 307.99 ## 3 34387 2021-05-25 11:08:02 0 993.38 ## 4 69520 2021-05-25 11:12:45 0 597.78 ## 5 34387 2021-05-25 11:47:00 1 -277.93 ## 6 69520 2021-05-25 11:48:08 1 -874.21 You can extend list on fly with $: list_data$ClientName ## [1] &quot;John Doe&quot; list_data$ClientId &lt;- 11125489656 list_data ## $ClientName ## [1] &quot;John Doe&quot; ## ## $IsActive ## [1] TRUE ## ## $Services ## [1] &quot;credit&quot; &quot;deposite&quot; &quot;online-app&quot; ## ## $Transactions ## contract_id datetime oper_type amount ## 1 34387 2021-05-25 11:05:12 1 -187.72 ## 2 69520 2021-05-25 11:07:14 0 307.99 ## 3 34387 2021-05-25 11:08:02 0 993.38 ## 4 69520 2021-05-25 11:12:45 0 597.78 ## 5 34387 2021-05-25 11:47:00 1 -277.93 ## 6 69520 2021-05-25 11:48:08 1 -874.21 ## ## $ClientId ## [1] 11125489656 3.6.3 Accessing List Elements For now every element can be viewed with index in [[]] or []: # access to list element list_data[1] ## $ClientName ## [1] &quot;John Doe&quot; typeof(list_data[1]) ## [1] &quot;list&quot; # access to object list_data[[1]] ## [1] &quot;John Doe&quot; typeof(list_data[[1]]) ## [1] &quot;character&quot; Access by $ also anbled: list_data$Transactions ## contract_id datetime oper_type amount ## 1 34387 2021-05-25 11:05:12 1 -187.72 ## 2 69520 2021-05-25 11:07:14 0 307.99 ## 3 34387 2021-05-25 11:08:02 0 993.38 ## 4 69520 2021-05-25 11:12:45 0 597.78 ## 5 34387 2021-05-25 11:47:00 1 -277.93 ## 6 69520 2021-05-25 11:48:08 1 -874.21 3.6.4 Manipulating List Elements Lets continue using out list_data list. list_data ## $ClientName ## [1] &quot;John Doe&quot; ## ## $IsActive ## [1] TRUE ## ## $Services ## [1] &quot;credit&quot; &quot;deposite&quot; &quot;online-app&quot; ## ## $Transactions ## contract_id datetime oper_type amount ## 1 34387 2021-05-25 11:05:12 1 -187.72 ## 2 69520 2021-05-25 11:07:14 0 307.99 ## 3 34387 2021-05-25 11:08:02 0 993.38 ## 4 69520 2021-05-25 11:12:45 0 597.78 ## 5 34387 2021-05-25 11:47:00 1 -277.93 ## 6 69520 2021-05-25 11:48:08 1 -874.21 ## ## $ClientId ## [1] 11125489656 We can change data with [] and access with $ symbol. # changing clint name with index list_data[1] &lt;- &quot;New Name&quot; list_data ## $ClientName ## [1] &quot;New Name&quot; ## ## $IsActive ## [1] TRUE ## ## $Services ## [1] &quot;credit&quot; &quot;deposite&quot; &quot;online-app&quot; ## ## $Transactions ## contract_id datetime oper_type amount ## 1 34387 2021-05-25 11:05:12 1 -187.72 ## 2 69520 2021-05-25 11:07:14 0 307.99 ## 3 34387 2021-05-25 11:08:02 0 993.38 ## 4 69520 2021-05-25 11:12:45 0 597.78 ## 5 34387 2021-05-25 11:47:00 1 -277.93 ## 6 69520 2021-05-25 11:48:08 1 -874.21 ## ## $ClientId ## [1] 11125489656 # changing data with $ list_data$ClientName = &quot;John Doe&quot; list_data ## $ClientName ## [1] &quot;John Doe&quot; ## ## $IsActive ## [1] TRUE ## ## $Services ## [1] &quot;credit&quot; &quot;deposite&quot; &quot;online-app&quot; ## ## $Transactions ## contract_id datetime oper_type amount ## 1 34387 2021-05-25 11:05:12 1 -187.72 ## 2 69520 2021-05-25 11:07:14 0 307.99 ## 3 34387 2021-05-25 11:08:02 0 993.38 ## 4 69520 2021-05-25 11:12:45 0 597.78 ## 5 34387 2021-05-25 11:47:00 1 -277.93 ## 6 69520 2021-05-25 11:48:08 1 -874.21 ## ## $ClientId ## [1] 11125489656 Yo can merge lists with c() function. Lets create new list and attach it to the list_data: list_2 &lt;- list(Consultant = list(Name = &quot;David Cameron&quot;, PhoneNum = &quot;+9562311855&quot;)) list_2 ## $Consultant ## $Consultant$Name ## [1] &quot;David Cameron&quot; ## ## $Consultant$PhoneNum ## [1] &quot;+9562311855&quot; list_data &lt;- c(list_data, list_2) list_data ## $ClientName ## [1] &quot;John Doe&quot; ## ## $IsActive ## [1] TRUE ## ## $Services ## [1] &quot;credit&quot; &quot;deposite&quot; &quot;online-app&quot; ## ## $Transactions ## contract_id datetime oper_type amount ## 1 34387 2021-05-25 11:05:12 1 -187.72 ## 2 69520 2021-05-25 11:07:14 0 307.99 ## 3 34387 2021-05-25 11:08:02 0 993.38 ## 4 69520 2021-05-25 11:12:45 0 597.78 ## 5 34387 2021-05-25 11:47:00 1 -277.93 ## 6 69520 2021-05-25 11:48:08 1 -874.21 ## ## $ClientId ## [1] 11125489656 ## ## $Consultant ## $Consultant$Name ## [1] &quot;David Cameron&quot; ## ## $Consultant$PhoneNum ## [1] &quot;+9562311855&quot; With unlist() you can convert a list to a vector. list_demo &lt;- list(1:10) list_demo ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 class(list_demo) ## [1] &quot;list&quot; typeof(list_demo) ## [1] &quot;list&quot; list_demo * 5 # error, you cannot use * for list lapply(list_demo, function(c) c*5) ## [[1]] ## [1] 5 10 15 20 25 30 35 40 45 50 vector_demo &lt;- unlist(list_demo) vector_demo ## [1] 1 2 3 4 5 6 7 8 9 10 class(vector_demo) ## [1] &quot;integer&quot; typeof(vector_demo) ## [1] &quot;integer&quot; vector_demo * 5 # now it works ## [1] 5 10 15 20 25 30 35 40 45 50 3.6.5 TASKS Task 1 Wrie a function that calculates sum, average, median, min, max of taken vector. Generate sample vector of 10 elements in \\([1;100]\\). Solution x &lt;- sample(10:100, size = 10) print(x) ## [1] 94 46 98 99 43 53 88 42 44 79 vector_info &lt;- function(vector) { x &lt;- list() x$Sum &lt;- sum(vector) x$Mean &lt;- mean(vector) x$Median &lt;- median(vector) x$Min &lt;- min(vector) x$Max &lt;- max(vector) return(x) } vector_info(x) ## $Sum ## [1] 686 ## ## $Mean ## [1] 68.6 ## ## $Median ## [1] 66 ## ## $Min ## [1] 42 ## ## $Max ## [1] 99 names(vector_info(x)) ## [1] &quot;Sum&quot; &quot;Mean&quot; &quot;Median&quot; &quot;Min&quot; &quot;Max&quot; 3.7 Apply functions family You can use a set of function for manipulating, accesing different data structures such as data.frame, list. 3.7.1 The apply() functions family The apply() family pertains to the R base package and is populated with functions to manipulate slices of data from matrices, arrays, lists and dataframes in a repetitive way. These functions allow crossing the data in a number of ways and avoid explicit use of loop constructs. They act on an input list, matrix or array and apply a named function with one or several optional arguments. The called function could be: An aggregating function, like for example the mean, or the sum (that return a number or scalar); Other transforming or subsetting functions; and Other vectorized functions, which yield more complex structures like lists, vectors, matrices, and arrays. The apply() functions form the basis of more complex combinations and helps to perform operations with very few lines of code. More specifically, the family is made up of the apply(), lapply(), sapply(), vapply(), mapply(), rapply(), and tapply() functions. Using of any functions depends on the structure of the data that you want to operate on and the format of the output that you need. 3.7.2 apply() apply() operates on arrays (2D arrays are matrices). Syntax is next: apply(X, MARGIN, FUN, ), where X is an array or a matrix if the dimension of the array is 2; MARGIN is a variable defining how the function is applied: when MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns. Note that when you use the construct MARGIN=c(1,2), it applies to both rows and columns; and FUN, which is the function that you want to apply to the data. It can be any R function, including a User Defined Function (UDF). # create a matrix matrix &lt;- matrix(10:29, ncol = 5, nrow = 4) matrix ## [,1] [,2] [,3] [,4] [,5] ## [1,] 10 14 18 22 26 ## [2,] 11 15 19 23 27 ## [3,] 12 16 20 24 28 ## [4,] 13 17 21 25 29 # find sums by col apply(matrix, 2, sum) ## [1] 46 62 78 94 110 It your turn. TASK. Calculate average value of all rows: apply(matrix, 1, mean) ## [1] 18 19 20 21 3.7.3 lapply() lapply() from apply() is: It can be used for other objects like dataframes, lists or vectors; and The output returned is a list (which explains the l in the function name), which has the same number of elements as the object passed to it. ?lapply to check params of fucntion: ?lapply Lets create list of data.frames: df_a &lt;- data.frame(Value1 = 1:5, Value2 = 101:105) df_a ## Value1 Value2 ## 1 1 101 ## 2 2 102 ## 3 3 103 ## 4 4 104 ## 5 5 105 df_b &lt;- data.frame(Value1 = 11:15, Value2 = 201:205) df_c &lt;- data.frame(Value1 = 16:20, Value2 = 301:305) df_c ## Value1 Value2 ## 1 16 301 ## 2 17 302 ## 3 18 303 ## 4 19 304 ## 5 20 305 lapply(df_a$Value1, sum) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 ## ## [[5]] ## [1] 5 list_demo &lt;- list(df_a, df_b, df_c) list_demo ## [[1]] ## Value1 Value2 ## 1 1 101 ## 2 2 102 ## 3 3 103 ## 4 4 104 ## 5 5 105 ## ## [[2]] ## Value1 Value2 ## 1 11 201 ## 2 12 202 ## 3 13 203 ## 4 14 204 ## 5 15 205 ## ## [[3]] ## Value1 Value2 ## 1 16 301 ## 2 17 302 ## 3 18 303 ## 4 19 304 ## 5 20 305 # lets select the 2nd row of each data frame lapply(list_demo, &quot;[&quot;, 2) ## [[1]] ## Value2 ## 1 101 ## 2 102 ## 3 103 ## 4 104 ## 5 105 ## ## [[2]] ## Value2 ## 1 201 ## 2 202 ## 3 203 ## 4 204 ## 5 205 ## ## [[3]] ## Value2 ## 1 301 ## 2 302 ## 3 303 ## 4 304 ## 5 305 # list_demo - data # &quot;[&quot; - selection operator # row index # col index TASK. Its your turn. Select all 1st rows of dataframes lapply(list_demo, &quot;[&quot;, 1,) ## [[1]] ## Value1 Value2 ## 1 1 101 ## ## [[2]] ## Value1 Value2 ## 1 11 201 ## ## [[3]] ## Value1 Value2 ## 1 16 301 TASK. Its your turn. Select all 1st elements (1st row, 1st col) lapply(list_demo, &quot;[&quot;, 1, 1) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 11 ## ## [[3]] ## [1] 16 You can apply function to all elemetns. Lets make some names in lowercase names_list &lt;- list(&quot;John&quot;, &quot;Jane&quot;, &quot;Jake&quot;, &quot;Jacob&quot;) lower_names &lt;- lapply(names_list, tolower) class(lower_names) ## [1] &quot;list&quot; 3.7.4 sapplay() sapply() takes a list vector or dataframe as an input and returns the output in vector or matrix form. Lets use sapply() function in the previous example and check the result. sapply(names_list, tolower) ## [1] &quot;john&quot; &quot;jane&quot; &quot;jake&quot; &quot;jacob&quot; It tries to simplify the output to the most elementary data structure that is possible. And indeed, sapply() is a wrapper function for lapply(). Lets try to get every 1st element of 2nd row from out list_demo: list_demo ## [[1]] ## Value1 Value2 ## 1 1 101 ## 2 2 102 ## 3 3 103 ## 4 4 104 ## 5 5 105 ## ## [[2]] ## Value1 Value2 ## 1 11 201 ## 2 12 202 ## 3 13 203 ## 4 14 204 ## 5 15 205 ## ## [[3]] ## Value1 Value2 ## 1 16 301 ## 2 17 302 ## 3 18 303 ## 4 19 304 ## 5 20 305 data &lt;- sapply(list_demo, &quot;[&quot;, 2,1) data ## [1] 2 12 17 class(data) ## [1] &quot;integer&quot; # lest set simplify = FASLE data &lt;- sapply(list_demo, &quot;[&quot;, 2,1, simplify =F) data ## [[1]] ## [1] 2 ## ## [[2]] ## [1] 12 ## ## [[3]] ## [1] 17 class(data) ## [1] &quot;list&quot; 3.7.5 aggregate() This function is from package stats. It often used for grouping data by some key. Its from apply family, but working in the same way. So, its good idea discuss it now. Syntax for data.frame: aggregate(x, # R object \\ by, # List of variables (grouping elements) \\ FUN, # Function to be applied for summary statistics\\ ..., # Additional arguments to be passed to FUN\\ simplify = TRUE, # Whether to simplify results as much as possible or not\\ drop = TRUE) # Whether to drop unused combinations of grouping values or not. Formula aggregate(formula, # Input formula \\ data, # List or data frame where the variables are stored \\ FUN, # Function to be applied for summary statistics \\ ..., # Additional arguments to be passed to FUN \\ subset, # Observations to be used (optional) \\ na.action = na.omit) # How to deal with NA values` Lets use our credit_data from one of the previous tasks: credit_data &lt;- ISLR::Credit head(credit_data) ## ID Income Limit Rating Cards Age Education Gender Student Married Ethnicity ## 1 1 14.891 3606 283 2 34 11 Male No Yes Caucasian ## 2 2 106.025 6645 483 3 82 15 Female Yes Yes Asian ## 3 3 104.593 7075 514 4 71 11 Male No No Asian ## 4 4 148.924 9504 681 3 36 11 Female No No Asian ## 5 5 55.882 4897 357 2 68 16 Male No Yes Caucasian ## 6 6 80.180 8047 569 4 77 10 Male No No Caucasian ## Balance ## 1 333 ## 2 903 ## 3 580 ## 4 964 ## 5 331 ## 6 1151 TASK 1. Calculate average Balance by Gender: # lets use formula syntax mean_age &lt;- aggregate(Age ~ Gender, data = credit_data, mean) mean_age ## Gender Age ## 1 Male 55.59585 ## 2 Female 55.73430 n &lt;- names(mean_age) n[n == &quot;Age&quot;] = &quot;Mean Age&quot; names(mean_age) = n mean_age ## Gender Mean Age ## 1 Male 55.59585 ## 2 Female 55.73430 TASK 2. Average Balance for Gender and Student status at the same time group_bal &lt;- aggregate(Age ~ Gender + Married, data = credit_data, mean) group_bal ## Gender Married Age ## 1 Male No 57.13158 ## 2 Female No 57.36709 ## 3 Male Yes 54.59829 ## 4 Female Yes 54.72656 Task 3. FOR STUDENTS. Try get aggregated average Income by Age. Order final dat.frame by age and make a plot(). group_inc &lt;- aggregate(Income ~ Age + Gender, data = credit_data, mean) head(group_inc, 10) ## Age Gender Income ## 1 24 Male 25.97400 ## 2 25 Male 29.56700 ## 3 26 Male 16.47900 ## 4 27 Male 39.70500 ## 5 28 Male 33.01700 ## 6 29 Male 17.95850 ## 7 30 Male 35.10467 ## 8 31 Male 43.52567 ## 9 32 Male 33.71150 ## 10 33 Male 39.39733 levels(group_inc$Gender) ## [1] &quot; Male&quot; &quot;Female&quot; levels(group_inc$Gender) &lt;- c(&quot;Male&quot;, &quot;Female&quot;) m_data &lt;- group_inc[group_inc$Gender == &quot;Male&quot;, ] nrow(m_data) ## [1] 63 f_data &lt;- group_inc[group_inc$Gender == &quot;Female&quot;, ] nrow(f_data) ## [1] 62 with(m_data, plot(Age, Income, type = &quot;l&quot;, col=&quot;red&quot;)) with(f_data, lines(Age, Income, type = &quot;l&quot;, col =&quot;blue&quot;)) #plot(group_inc$Age, group_inc$Income, type = &quot;b&quot;) 3.8 References The Comprehensive R Archive NetworkRcran: Url: https://cran.r-project.org/ RStudio official website. Url: https://rstudio.com/ Anaconda official website. Url: https://www.anaconda.com/ Introduction to R. Datacamp interactive course. Url: https://www.datacamp.com/courses/free-introduction-to-r Quanargo. Introduction to R. Url: https://www.quantargo.com/courses/course-r-introduction R Coder Project. Begin your data science career with R language! Url: https://r-coder.com/ R Core Team (2019). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria.URL https://www.R-project.org/. A.B. Shipunov, EM Baldin, P.A. Volkova, VG Sufiyanov. Visual statistics. We use R! - M .: DMK Press, 2012. - 298 p .: ill. An Introduction to R. URL: https://cran.r-project.org/doc/manuals/r-release/R-intro.html R programming. https://www.datamentor.io/r-programming Learn R. R Functions. https://www.w3schools.com/r/r_functions.asp UC Business Analytics R Programming Guide. Managing Data Frames. http://uc-r.github.io/dataframes Learn R programming. R - Lists. https://www.tutorialspoint.com/r/r_lists.htm Tutorial on the R Apply Family by Carlo Fanara. https://www.datacamp.com/community/tutorials/r-tutorial-apply-family "],["chapter4.html", " 4       : , -,  R 4.1     4.2    Telecom Users 4.3    RStudio 4.4 CSV-: ,  4.5 Excel (xlsx): ,  4.6 XML: ,  4.7 JSON and API 4.8 Google Services 4.9 SQL (SQLite sample) 4.10 Web-pages (HTML) 4.11 References", "  4       : , -,  R :  ,   4.1         .  ,         3 :         ,          ,    .        ,       ,   .       ,          .       , ,  Microsoft Excel,    -   ,    -   .                 .       ,   ,      .   4.2    Telecom Users         kaggle.com.      https://www.kaggle.com/radmirzosimov/telecom-users-dataset. :            . : Any business wants to maximize the number of customers. To achieve this goal, it is important not only to try to attract new ones, but also to retain existing ones. Retaining a client will cost the company less than attracting a new one. In addition, a new client may be weakly interested in business services and it will be difficult to work with him, while old clients already have the necessary data on interaction with the service. Accordingly, predicting the churn, we can react in time and try to keep the client who wants to leave. Based on the data about the services that the client uses, we can make him a special offer, trying to change his decision to leave the operator. This will make the task of retention easier to implement than the task of attracting new users, about which we do not know anything yet. You are provided with a dataset from a telecommunications company. The data contains information about almost six thousand users, their demographic characteristics, the services they use, the duration of using the operators services, the method of payment, and the amount of payment. The task is to analyze the data and predict the churn of users (to identify people who will and will not renew their contract). The work should include the following mandatory items: Description of the data (with the calculation of basic statistics); Research of dependencies and formulation of hypotheses; Building models for predicting the outflow (with justification for the choice of a particular model) 4. based on tested hypotheses and identified relationships; Comparison of the quality of the obtained models.    : customerID - customer id gender - client gender (male / female) SeniorCitizen - is the client retired (1, 0) Partner - is the client married (Yes, No) tenure - how many months a person has been a client of the company PhoneService - is the telephone service connected (Yes, No) MultipleLines - are multiple phone lines connected (Yes, No, No phone service) InternetService - clients Internet service provider (DSL, Fiber optic, No) OnlineSecurity - is the online security service connected (Yes, No, No internet service) OnlineBackup - is the online backup service activated (Yes, No, No internet service) DeviceProtection - does the client have equipment insurance (Yes, No, No internet service) TechSupport - is the technical support service connected (Yes, No, No internet service) StreamingTV - is the streaming TV service connected (Yes, No, No internet service) StreamingMovies - is the streaming cinema service activated (Yes, No, No internet service) Contract - type of customer contract (Month-to-month, One year, Two year) PaperlessBilling - whether the client uses paperless billing (Yes, No) PaymentMethod - payment method (Electronic check, Mailed check, Bank transfer (automatic), Credit card (automatic)) MonthlyCharges - current monthly payment TotalCharges - the total amount that the client paid for the services for the entire time Churn - whether there was a churn (Yes or No) 4.3    RStudio RStudio     4.4 CSV-: ,  CSV -   ,      (Comma Separated Values). CSV          ,           . .       CSV-.      . # lets check current working directory to write correct files path getwd() ## [1] &quot;E:/Repos/YuRa/r-science-dev&quot; You can use / or \\ for writing correct path in R. For example: path = &quot;d:/projects/file.csv&quot; path = &quot;d:\\\\projects\\\\file.csv&quot; To combine path use paste() or paste0() functions work_dir = getwd() work_dir ## [1] &quot;E:/Repos/YuRa/r-science-dev&quot; file_name = &quot;temp_file.csv&quot; file_path = paste0(work_dir, &quot;/&quot;, file_name) file_path ## [1] &quot;E:/Repos/YuRa/r-science-dev/temp_file.csv&quot; file_path = paste(work_dir, file_name, sep = &quot;/&quot;) file_path ## [1] &quot;E:/Repos/YuRa/r-science-dev/temp_file.csv&quot; Thare are few methods for reading/writing csv in base package: read.csv(), write.csv - default data separator is ,, decimal is separator .. read.csv2(), write.csv2 - default data separator is ;, decimal is separator ,. Before using any new function check it usage information with help(function_name) or ?function_name,example:?read.csv`. You can read (current data set has NA values as example, there are no NA in original datase): data &lt;- read.csv2(&quot;data/telecom_users.csv&quot;) # default reading data &lt;- read.csv2(&quot;data/telecom_users.csv&quot;, sep = &quot;,&quot;, # comma not only possibel separator dec = &quot;.&quot;, # decimal separator can be different na.strings = c(&quot;&quot;, &quot;NA&quot;, &quot;NULL&quot;)) # you can define NA values str(data) # chack data structure / types/ values ## &#39;data.frame&#39;: 5986 obs. of 22 variables: ## $ X : int 1869 4528 6344 6739 432 2215 5260 6001 1480 5137 ... ## $ customerID : chr &quot;7010-BRBUU&quot; &quot;9688-YGXVR&quot; &quot;9286-DOJGF&quot; &quot;6994-KERXL&quot; ... ## $ gender : chr &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; ... ## $ SeniorCitizen : int 0 0 1 0 0 0 0 0 0 1 ... ## $ Partner : chr &quot;Yes&quot; &quot;No&quot; &quot;Yes&quot; &quot;No&quot; ... ## $ Dependents : chr &quot;Yes&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; ... ## $ tenure : int 72 44 38 4 2 70 33 1 39 55 ... ## $ PhoneService : chr &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; ... ## $ MultipleLines : chr &quot;Yes&quot; &quot;No&quot; &quot;Yes&quot; &quot;No&quot; ... ## $ InternetService : chr &quot;No&quot; &quot;Fiber optic&quot; &quot;Fiber optic&quot; &quot;DSL&quot; ... ## $ OnlineSecurity : chr &quot;No internet service&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; ... ## $ OnlineBackup : chr &quot;No internet service&quot; &quot;Yes&quot; &quot;No&quot; &quot;No&quot; ... ## $ DeviceProtection: chr &quot;No internet service&quot; &quot;Yes&quot; &quot;No&quot; &quot;No&quot; ... ## $ TechSupport : chr &quot;No internet service&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; ... ## $ StreamingTV : chr &quot;No internet service&quot; &quot;Yes&quot; &quot;No&quot; &quot;No&quot; ... ## $ StreamingMovies : chr &quot;No internet service&quot; &quot;No&quot; &quot;No&quot; &quot;Yes&quot; ... ## $ Contract : chr &quot;Two year&quot; &quot;Month-to-month&quot; &quot;Month-to-month&quot; &quot;Month-to-month&quot; ... ## $ PaperlessBilling: chr &quot;No&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; ... ## $ PaymentMethod : chr &quot;Credit card (automatic)&quot; &quot;Credit card (automatic)&quot; &quot;Bank transfer (automatic)&quot; &quot;Electronic check&quot; ... ## $ MonthlyCharges : num 24.1 88.2 75 55.9 53.5 ... ## $ TotalCharges : num 1735 3973 2870 238 120 ... ## $ Churn : chr &quot;No&quot; &quot;No&quot; &quot;Yes&quot; &quot;No&quot; ... head(data) # top 6 rows, use n = X, for viewing top X lines ## X customerID gender SeniorCitizen Partner Dependents tenure PhoneService ## 1 1869 7010-BRBUU Male 0 Yes Yes 72 Yes ## 2 4528 9688-YGXVR Female 0 No No 44 Yes ## 3 6344 9286-DOJGF Female 1 Yes No 38 Yes ## 4 6739 6994-KERXL Male 0 No No 4 Yes ## 5 432 2181-UAESM Male 0 No No 2 Yes ## 6 2215 4312-GVYNH Female 0 Yes No 70 No ## MultipleLines InternetService OnlineSecurity OnlineBackup ## 1 Yes No No internet service No internet service ## 2 No Fiber optic No Yes ## 3 Yes Fiber optic No No ## 4 No DSL No No ## 5 No DSL Yes No ## 6 No phone service DSL Yes No ## DeviceProtection TechSupport StreamingTV ## 1 No internet service No internet service No internet service ## 2 Yes No Yes ## 3 No No No ## 4 No No No ## 5 Yes No No ## 6 Yes Yes No ## StreamingMovies Contract PaperlessBilling PaymentMethod ## 1 No internet service Two year No Credit card (automatic) ## 2 No Month-to-month Yes Credit card (automatic) ## 3 No Month-to-month Yes Bank transfer (automatic) ## 4 Yes Month-to-month Yes Electronic check ## 5 No Month-to-month No Electronic check ## 6 Yes Two year Yes Bank transfer (automatic) ## MonthlyCharges TotalCharges Churn ## 1 24.10 1734.65 No ## 2 88.15 3973.20 No ## 3 74.95 2869.85 Yes ## 4 55.90 238.50 No ## 5 53.45 119.50 No ## 6 49.85 3370.20 No is.data.frame(data) # if data is data.frame ## [1] TRUE any(is.na(data)) # if dataframe contains any NA values ## [1] TRUE apply(is.na(data), 2, any) #check NA by 2nd dimension - columns ## X customerID gender SeniorCitizen ## FALSE FALSE FALSE FALSE ## Partner Dependents tenure PhoneService ## FALSE FALSE FALSE FALSE ## MultipleLines InternetService OnlineSecurity OnlineBackup ## FALSE FALSE FALSE FALSE ## DeviceProtection TechSupport StreamingTV StreamingMovies ## FALSE FALSE FALSE FALSE ## Contract PaperlessBilling PaymentMethod MonthlyCharges ## FALSE FALSE FALSE TRUE ## TotalCharges Churn ## TRUE FALSE Check MonthlyCharges: TRUE and TotalCharges: TRUE. These columns has NA-values. Lets replace them with mean: data[is.na(data$TotalCharges), &quot;TotalCharges&quot;] &lt;- mean(data$TotalCharges, na.rm = T) data[is.na(data$MonthlyCharges), &quot;MonthlyCharges&quot;] &lt;- mean(data$MonthlyCharges, na.rm = T) any(is.na(data)) # check for NA ## [1] FALSE You can write data with write.csv(), write.csv2() from base package. write.csv(data, file = &quot;data/cleaned_data.csv&quot;, row.names = F) # by default row.names = TRUE and file will contains first columns with row numbers 1,2, ..., N One more useful package is readr. Examples of using: #install.packages(readr) library(readr) data &lt;- read_csv(file = &quot;data/telecom_users.csv&quot;,  ) data &lt;- read_csv2(file = &quot;data/telecom_users.csv&quot;,  ) 4.5 Excel (xlsx): ,  There are many packages to read/write MS Excel files. xlsx one of the most useful. #install.packages(&quot;xlsx&quot;) install before use it library(xlsx) any(grepl(&quot;xlsx&quot;, installed.packages())) # check if package installed ## [1] TRUE ?read.xlsx - review package functions and params Lets read the data telecom_users.xlsx: data &lt;- read.xlsx(&quot;data/telecom_users.xlsx&quot;, sheetIndex = 1) # sheetIndex = 1 - select sheet to read, or use sheetName = &quot;sheet1&quot; to read by Name # You can also use startRow, endRow and other params to define how mutch data read data &lt;- read.xlsx(&quot;data/telecom_users.xlsx&quot;, sheetIndex = 1, endRow = 100) Lets replace Churn values Yes/No by 1/0: head(data$Churn) ## [1] &quot;No&quot; &quot;No&quot; &quot;Yes&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; data$Churn &lt;- ifelse(data$Churn == &quot;Yes&quot;, 1, 0) head(data$Churn) ## [1] 0 0 1 0 0 0 Write final data to csv: write.xlsx(data, file = &quot;data/final_telecom_data.xlsx&quot;) 4.5.1 Task 2.1 Download from kaggle.com and read dataset Default_Fin.csv: https://www.kaggle.com/kmldas/loan-default-prediction Description: This is a synthetic dataset created using actual data from a financial institution. The data has been modified to remove identifiable features and the numbers transformed to ensure they do not link to original source (financial institution). This is intended to be used for academic purposes for beginners who want to practice financial analytics from a simple financial dataset. Index - This is the serial number or unique identifier of the loan taker Employed - This is a Boolean 1= employed 0= unemployed Bank.Balance - Bank Balance of the loan taker Annual.Salary - Annual salary of the loan taker Defaulted - This is a Boolean 1= defaulted 0= not defaulted Check what columns has missing values Count default and non-default clients / and parts of total clients in % Count Employed clients Count Employed Default clients Average salary by Employed clients Rename columns to id, empl, balance, salary, default 4.5.2 Solution for Task 2.1 data &lt;- read.csv(&quot;data/Default_Fin.csv&quot;) head(data) ## Index Employed Bank.Balance Annual.Salary Defaulted. ## 1 1 1 8754.36 532339.56 0 ## 2 2 0 9806.16 145273.56 0 ## 3 3 1 12882.60 381205.68 0 ## 4 4 1 6351.00 428453.88 0 ## 5 5 1 9427.92 461562.00 0 ## 6 6 0 11035.08 89898.72 0 Check what columns has missing values any(is.na(data)) ## [1] FALSE Count default and non-default clients / and parts of total clients in % def_count &lt;- nrow(data[data$Defaulted. == 1, ]) no_def_count &lt;- nrow(data[data$Defaulted. == 0, ]) def_count ## [1] 333 no_def_count ## [1] 9667 def_count / nrow(data) * 100 # part defaults ## [1] 3.33 no_def_count / nrow(data) * 100 # part non-defaults ## [1] 96.67 Count Employed clients empl &lt;- data[data$Employed == 1, ] nrow(empl) ## [1] 7056 Count Employed Default clients empl &lt;- data[data$Employed == 1 &amp; data$Defaulted. == 1, ] nrow(empl) ## [1] 206 Average salary by Employed clients empl &lt;- data[data$Employed == 1, ] mean(empl$Annual.Salary) ## [1] 480143.4 Rename columns to id, empl, balance, salary, default: colnames(data) &lt;- c(&quot;id&quot;, &quot;empl&quot;, &quot;balance&quot;, &quot;salary&quot;, &quot;default&quot;) head(data) ## id empl balance salary default ## 1 1 1 8754.36 532339.56 0 ## 2 2 0 9806.16 145273.56 0 ## 3 3 1 12882.60 381205.68 0 ## 4 4 1 6351.00 428453.88 0 ## 5 5 1 9427.92 461562.00 0 ## 6 6 0 11035.08 89898.72 0 4.6 XML: ,  XML - eXtensible Markup Language. For our example we will use data from data/employes.xml. File contains records with info: &lt;RECORDS&gt; &lt;EMPLOYEE&gt; &lt;ID&gt;1&lt;/ID&gt; &lt;NAME&gt;Rick&lt;/NAME&gt; &lt;SALARY&gt;623.3&lt;/SALARY&gt; &lt;STARTDATE&gt;1/1/2012&lt;/STARTDATE&gt; &lt;DEPT&gt;IT&lt;/DEPT&gt; &lt;/EMPLOYEE&gt; ... &lt;/RECORDS&gt; #install.packages(&quot;XML&quot;) library(&quot;XML&quot;) #install.packages(&quot;methods&quot;) library(&quot;methods&quot;) result &lt;- xmlParse(file = &quot;data/employes.xml&quot;) print(result) ## &lt;?xml version=&quot;1.0&quot;?&gt; ## &lt;RECORDS&gt; ## &lt;EMPLOYEE&gt; ## &lt;ID&gt;1&lt;/ID&gt; ## &lt;NAME&gt;Rick&lt;/NAME&gt; ## &lt;SALARY&gt;623.3&lt;/SALARY&gt; ## &lt;STARTDATE&gt;1/1/2012&lt;/STARTDATE&gt; ## &lt;DEPT&gt;IT&lt;/DEPT&gt; ## &lt;/EMPLOYEE&gt; ## &lt;EMPLOYEE&gt; ## &lt;ID&gt;2&lt;/ID&gt; ## &lt;NAME&gt;Dan&lt;/NAME&gt; ## &lt;SALARY&gt;515.2&lt;/SALARY&gt; ## &lt;STARTDATE&gt;9/23/2013&lt;/STARTDATE&gt; ## &lt;DEPT&gt;Operations&lt;/DEPT&gt; ## &lt;/EMPLOYEE&gt; ## &lt;EMPLOYEE&gt; ## &lt;ID&gt;3&lt;/ID&gt; ## &lt;NAME&gt;Michelle&lt;/NAME&gt; ## &lt;SALARY&gt;611&lt;/SALARY&gt; ## &lt;STARTDATE&gt;11/15/2014&lt;/STARTDATE&gt; ## &lt;DEPT&gt;IT&lt;/DEPT&gt; ## &lt;/EMPLOYEE&gt; ## &lt;EMPLOYEE&gt; ## &lt;ID&gt;4&lt;/ID&gt; ## &lt;NAME&gt;Ryan&lt;/NAME&gt; ## &lt;SALARY&gt;729&lt;/SALARY&gt; ## &lt;STARTDATE&gt;5/11/2014&lt;/STARTDATE&gt; ## &lt;DEPT&gt;HR&lt;/DEPT&gt; ## &lt;/EMPLOYEE&gt; ## &lt;EMPLOYEE&gt; ## &lt;ID&gt;5&lt;/ID&gt; ## &lt;NAME&gt;Gary&lt;/NAME&gt; ## &lt;SALARY&gt;843.25&lt;/SALARY&gt; ## &lt;STARTDATE&gt;3/27/2015&lt;/STARTDATE&gt; ## &lt;DEPT&gt;Finance&lt;/DEPT&gt; ## &lt;/EMPLOYEE&gt; ## &lt;EMPLOYEE&gt; ## &lt;ID&gt;6&lt;/ID&gt; ## &lt;NAME&gt;Nina&lt;/NAME&gt; ## &lt;SALARY&gt;578&lt;/SALARY&gt; ## &lt;STARTDATE&gt;5/21/2013&lt;/STARTDATE&gt; ## &lt;DEPT&gt;IT&lt;/DEPT&gt; ## &lt;/EMPLOYEE&gt; ## &lt;EMPLOYEE&gt; ## &lt;ID&gt;7&lt;/ID&gt; ## &lt;NAME&gt;Simon&lt;/NAME&gt; ## &lt;SALARY&gt;632.8&lt;/SALARY&gt; ## &lt;STARTDATE&gt;7/30/2013&lt;/STARTDATE&gt; ## &lt;DEPT&gt;Operations&lt;/DEPT&gt; ## &lt;/EMPLOYEE&gt; ## &lt;EMPLOYEE&gt; ## &lt;ID&gt;8&lt;/ID&gt; ## &lt;NAME&gt;Guru&lt;/NAME&gt; ## &lt;SALARY&gt;722.5&lt;/SALARY&gt; ## &lt;STARTDATE&gt;6/17/2014&lt;/STARTDATE&gt; ## &lt;DEPT&gt;Finance&lt;/DEPT&gt; ## &lt;/EMPLOYEE&gt; ## &lt;/RECORDS&gt; ## rootnode &lt;- xmlRoot(result) # reading rootnode of xml document rootnode[[1]] # reading first record ## &lt;EMPLOYEE&gt; ## &lt;ID&gt;1&lt;/ID&gt; ## &lt;NAME&gt;Rick&lt;/NAME&gt; ## &lt;SALARY&gt;623.3&lt;/SALARY&gt; ## &lt;STARTDATE&gt;1/1/2012&lt;/STARTDATE&gt; ## &lt;DEPT&gt;IT&lt;/DEPT&gt; ## &lt;/EMPLOYEE&gt; rootnode[[1]][[2]] # reading first record in root node and second tag, its &lt;NAME&gt; ## &lt;NAME&gt;Rick&lt;/NAME&gt; xmldataframe &lt;- xmlToDataFrame(&quot;data/employes.xml&quot;) xmldataframe ## ID NAME SALARY STARTDATE DEPT ## 1 1 Rick 623.3 1/1/2012 IT ## 2 2 Dan 515.2 9/23/2013 Operations ## 3 3 Michelle 611 11/15/2014 IT ## 4 4 Ryan 729 5/11/2014 HR ## 5 5 Gary 843.25 3/27/2015 Finance ## 6 6 Nina 578 5/21/2013 IT ## 7 7 Simon 632.8 7/30/2013 Operations ## 8 8 Guru 722.5 6/17/2014 Finance 4.7 JSON and API JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language Standard. API is the acronym for Application Programming Interface, which is a software intermediary that allows two applications to talk to each other. One of the most popular packages for json is jsonlite. #install.packages(&quot;jsonlite&quot;) library(jsonlite) Lets use readinginformation about BTC and USDT crypro currencies from Binance market = &#39;BTCUSDT&#39; interval = &#39;1h&#39; limit = 100 url &lt;- paste0(url = &quot;https://api.binance.com/api/v3/klines?symbol=&quot;, market ,&quot;&amp;interval=&quot;, interval,&quot;&amp;limit=&quot;, limit) print(url) # complete request URL ## [1] &quot;https://api.binance.com/api/v3/klines?symbol=BTCUSDT&amp;interval=1h&amp;limit=100&quot; On the nex stage you need use fromJSON() function to get data. More details about requests to Binanace at https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#klinecandlestick-data If you enter url value at browser response is going to be like this: [ [ 1499040000000, // Open time &quot;0.01634790&quot;, // Open &quot;0.80000000&quot;, // High &quot;0.01575800&quot;, // Low &quot;0.01577100&quot;, // Close &quot;148976.11427815&quot;, // Volume 1499644799999, // Close time &quot;2434.19055334&quot;, // Quote asset volume 308, // Number of trades &quot;1756.87402397&quot;, // Taker buy base asset volume &quot;28.46694368&quot;, // Taker buy quote asset volume &quot;17928899.62484339&quot; // Ignore. ] ] data &lt;- fromJSON(url) # get json and transform it to list() data &lt;- data[, 1:7] # let&#39;s left only 1:7 columns (from Open time to Close time) head(data) ## [,1] [,2] [,3] [,4] ## [1,] &quot;1.625904e+12&quot; &quot;33766.01000000&quot; &quot;33950.00000000&quot; &quot;33686.00000000&quot; ## [2,] &quot;1625907600000&quot; &quot;33761.72000000&quot; &quot;33900.00000000&quot; &quot;33711.95000000&quot; ## [3,] &quot;1625911200000&quot; &quot;33735.98000000&quot; &quot;33800.00000000&quot; &quot;33599.98000000&quot; ## [4,] &quot;1625914800000&quot; &quot;33624.09000000&quot; &quot;33911.82000000&quot; &quot;33565.00000000&quot; ## [5,] &quot;1625918400000&quot; &quot;33793.95000000&quot; &quot;33943.40000000&quot; &quot;33744.40000000&quot; ## [6,] &quot;1.625922e+12&quot; &quot;33858.28000000&quot; &quot;33898.17000000&quot; &quot;33634.16000000&quot; ## [,5] [,6] [,7] ## [1,] &quot;33762.79000000&quot; &quot;1586.69013400&quot; &quot;1625907599999&quot; ## [2,] &quot;33732.57000000&quot; &quot;988.18051900&quot; &quot;1625911199999&quot; ## [3,] &quot;33624.08000000&quot; &quot;1314.38690600&quot; &quot;1625914799999&quot; ## [4,] &quot;33793.94000000&quot; &quot;1674.95679800&quot; &quot;1625918399999&quot; ## [5,] &quot;33861.02000000&quot; &quot;1213.69747000&quot; &quot;1625921999999&quot; ## [6,] &quot;33700.31000000&quot; &quot;1331.15612700&quot; &quot;1625925599999&quot; typeof(data) # check data type ## [1] &quot;character&quot; data &lt;- as.data.frame(data) # convert to dataframe head(data) ## V1 V2 V3 V4 V5 ## 1 1.625904e+12 33766.01000000 33950.00000000 33686.00000000 33762.79000000 ## 2 1625907600000 33761.72000000 33900.00000000 33711.95000000 33732.57000000 ## 3 1625911200000 33735.98000000 33800.00000000 33599.98000000 33624.08000000 ## 4 1625914800000 33624.09000000 33911.82000000 33565.00000000 33793.94000000 ## 5 1625918400000 33793.95000000 33943.40000000 33744.40000000 33861.02000000 ## 6 1.625922e+12 33858.28000000 33898.17000000 33634.16000000 33700.31000000 ## V6 V7 ## 1 1586.69013400 1625907599999 ## 2 988.18051900 1625911199999 ## 3 1314.38690600 1625914799999 ## 4 1674.95679800 1625918399999 ## 5 1213.69747000 1625921999999 ## 6 1331.15612700 1625925599999 # fix columns names colnames(data) &lt;- c(&quot;Open_time&quot;, &quot;Open&quot;, &quot;High&quot;, &quot;Low&quot;, &quot;Close&quot;, &quot;Volume&quot;, &quot;Close_time&quot;) head(data) # looks better, but columns are characters still ## Open_time Open High Low Close ## 1 1.625904e+12 33766.01000000 33950.00000000 33686.00000000 33762.79000000 ## 2 1625907600000 33761.72000000 33900.00000000 33711.95000000 33732.57000000 ## 3 1625911200000 33735.98000000 33800.00000000 33599.98000000 33624.08000000 ## 4 1625914800000 33624.09000000 33911.82000000 33565.00000000 33793.94000000 ## 5 1625918400000 33793.95000000 33943.40000000 33744.40000000 33861.02000000 ## 6 1.625922e+12 33858.28000000 33898.17000000 33634.16000000 33700.31000000 ## Volume Close_time ## 1 1586.69013400 1625907599999 ## 2 988.18051900 1625911199999 ## 3 1314.38690600 1625914799999 ## 4 1674.95679800 1625918399999 ## 5 1213.69747000 1625921999999 ## 6 1331.15612700 1625925599999 is.numeric(data[,1]) # check 1st column type is numeric ## [1] FALSE is.numeric(data[,2]) # check 2nd column type is numeric ## [1] FALSE data &lt;- as.data.frame(sapply(data, as.numeric)) # convert all columns to numeric head(data) # good, its double now ## Open_time Open High Low Close Volume Close_time ## 1 1.625904e+12 33766.01 33950.00 33686.00 33762.79 1586.6901 1.625908e+12 ## 2 1.625908e+12 33761.72 33900.00 33711.95 33732.57 988.1805 1.625911e+12 ## 3 1.625911e+12 33735.98 33800.00 33599.98 33624.08 1314.3869 1.625915e+12 ## 4 1.625915e+12 33624.09 33911.82 33565.00 33793.94 1674.9568 1.625918e+12 ## 5 1.625918e+12 33793.95 33943.40 33744.40 33861.02 1213.6975 1.625922e+12 ## 6 1.625922e+12 33858.28 33898.17 33634.16 33700.31 1331.1561 1.625926e+12 Final stage is to convert Open_time and Close_time to dates. data$Open_time &lt;- as.POSIXct(data$Open_time/1e3, origin = &#39;1970-01-01&#39;) data$Close_time &lt;- as.POSIXct(data$Close_time/1e3, origin = &#39;1970-01-01&#39;) head(data) ## Open_time Open High Low Close Volume ## 1 2021-07-10 11:00:00 33766.01 33950.00 33686.00 33762.79 1586.6901 ## 2 2021-07-10 12:00:00 33761.72 33900.00 33711.95 33732.57 988.1805 ## 3 2021-07-10 13:00:00 33735.98 33800.00 33599.98 33624.08 1314.3869 ## 4 2021-07-10 14:00:00 33624.09 33911.82 33565.00 33793.94 1674.9568 ## 5 2021-07-10 15:00:00 33793.95 33943.40 33744.40 33861.02 1213.6975 ## 6 2021-07-10 16:00:00 33858.28 33898.17 33634.16 33700.31 1331.1561 ## Close_time ## 1 2021-07-10 11:59:59 ## 2 2021-07-10 12:59:59 ## 3 2021-07-10 13:59:59 ## 4 2021-07-10 14:59:59 ## 5 2021-07-10 15:59:59 ## 6 2021-07-10 16:59:59 tail(data) # check last records ## Open_time Open High Low Close Volume ## 95 2021-07-14 09:00:00 31807.01 31942.35 31754.55 31835.47 1632.804 ## 96 2021-07-14 10:00:00 31829.03 32000.00 31825.56 31920.01 1452.030 ## 97 2021-07-14 11:00:00 31920.01 31996.00 31702.92 31751.48 1637.104 ## 98 2021-07-14 12:00:00 31751.48 32500.00 31550.00 32327.70 5200.598 ## 99 2021-07-14 13:00:00 32330.00 32707.27 32260.83 32427.58 2759.772 ## 100 2021-07-14 14:00:00 32427.59 32562.48 32423.09 32507.80 748.375 ## Close_time ## 95 2021-07-14 09:59:59 ## 96 2021-07-14 10:59:59 ## 97 2021-07-14 11:59:59 ## 98 2021-07-14 12:59:59 ## 99 2021-07-14 13:59:59 ## 100 2021-07-14 14:59:59 4.8 Google Services 4.8.1 Spreadsheets THIS CHAPTER IS UNDER CONSTRUCTION / Working with Google Spreadsheets need account authorization. googlesheets4 is a package to work with Google Sheets from R. #install.packages(&quot;googlesheets4&quot;) library(googlesheets4) You can read google documents after authentification on google service. There is sample code: read_sheet(&quot;https://docs.google.com/spreadsheets/d/1U6Cf_qEOhiR9AZqTqS3mbMF3zt2db48ZP5v3rkrAEJY/edit#gid=780868077&quot;) gs4_deauth() Lets read sample dataset gapminder. It detailed described in next paragraph. gs4_example(gapminder) 4.8.2 Trends Google Trends is a service for analyzing search requests by many filters like region (continent, country, locality), period (year, month), information category (business, education, hobby, healthcare), information type (news, shopping, video, images) https://trends.google.com/trends/ #install.packages(&#39;gtrendsR&#39;) #install.packages(&#39;ggplot2&#39;) library(gtrendsR) # loading package for Google Trends queries library(ggplot2) Lets configure out google trends query params keywords = c(&quot;Bitcoin-Kurs&quot;, &quot;FC Barcelona&quot;) # search keywords country = c(&#39;AT&#39;) # search region from https://support.google.com/business/answer/6270107?hl=en time = (&quot;2021-01-01 2021-05-17&quot;) # period channel = &#39;web&#39; # search channel: google search (&#39;news&#39; - google news, &#39;images&#39; - google images) # query trends = gtrends(keywords, gprop = channel, geo = country, time = time, tz = &quot;UTC&quot;) time_trend = trends$interest_over_time head(time_trend) # last 6 ## date hits keyword geo time gprop category ## 1 2021-01-01 7 Bitcoin-Kurs AT 2021-01-01 2021-05-17 web 0 ## 2 2021-01-02 0 Bitcoin-Kurs AT 2021-01-01 2021-05-17 web 0 ## 3 2021-01-03 6 Bitcoin-Kurs AT 2021-01-01 2021-05-17 web 0 ## 4 2021-01-04 6 Bitcoin-Kurs AT 2021-01-01 2021-05-17 web 0 ## 5 2021-01-05 0 Bitcoin-Kurs AT 2021-01-01 2021-05-17 web 0 ## 6 2021-01-06 0 Bitcoin-Kurs AT 2021-01-01 2021-05-17 web 0 tail(time_trend) # latest 6 ## date hits keyword geo time gprop category ## 269 2021-05-12 16 FC Barcelona AT 2021-01-01 2021-05-17 web 0 ## 270 2021-05-13 6 FC Barcelona AT 2021-01-01 2021-05-17 web 0 ## 271 2021-05-14 0 FC Barcelona AT 2021-01-01 2021-05-17 web 0 ## 272 2021-05-15 7 FC Barcelona AT 2021-01-01 2021-05-17 web 0 ## 273 2021-05-16 19 FC Barcelona AT 2021-01-01 2021-05-17 web 0 ## 274 2021-05-17 11 FC Barcelona AT 2021-01-01 2021-05-17 web 0 Lets visualize query results: plot &lt;- ggplot(data=time_trend, aes(x=date, y=hits, group=keyword, col=keyword)) + geom_line() + xlab(&#39;Time&#39;) + ylab(&#39;Relative Interest&#39;) + theme(legend.title = element_blank(), legend.position=&quot;bottom&quot;, legend.text=element_text(size=15)) + ggtitle(&quot;Google Search Volume&quot;) plot 4.9 SQL (SQLite sample) We are going to review working with database on SQLite, becouse it allows us not to install DB-server and start working with simple file. For now we will use RSQLite package. #install.packages(&quot;RSQLite&quot;) library(RSQLite) # let&#39;s use mtcars data set data(&quot;mtcars&quot;) # loads the data head(mtcars) # preview the data ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # create new db file db_path = paste0(&quot;data/cars_101.sqlite&quot;) # change file name for new create connection # create connection conn &lt;- dbConnect(RSQLite::SQLite(), db_path, overwrite = TRUE, append = FALSE) # for lecture content only # Write the mtcars dataset into a table names mtcars_data dbWriteTable(conn, &quot;cars_table&quot;, mtcars) # List all the tables available in the database dbListTables(conn) ## [1] &quot;cars_table&quot; table_data &lt;- dbGetQuery(conn, &quot;SELECT * FROM cars_table&quot;) head(table_data) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # close connection dbDisconnect(conn) You can write complex queries for many tables if you knowledge of SQL allows. 4.10 Web-pages (HTML) 4.11 References "],["chapter5.html", " 5    (    dplyr) 5.1 Whats dplyr 5.2 Exploring data with dplyr 5.3 Pipe (%&gt;%) operator 5.4 Refences", "  5    (    dplyr)     .        ,      https://github.com/kleban/r: 032_ETL. Manipulate data with dplyr.ipynb 033_ETL. Train Test Validation.ipynb 034_ETL. Feature engineering in R.ipynb 5.1 Whats dplyr The dplyr package is one of the most powerful and popular package in R for data manipulation. Working with data: Figure out what you want to do. Describe those tasks in the form of a computer program. Execute the program. The dplyr package makes these steps fast and easy: By constraining your options, it helps you think about your data manipulation challenges. It provides simple verbs, functions that correspond to the most common data manipulation tasks, to help you translate your thoughts into code. It uses efficient backends, so you spend less time waiting for the computer. Before use you should install package: #install.packages(&quot;dplyr&quot;) Next step is loading package: library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union Alternative way is to load tidyverse package with other attached: #install.packages(&quot;tidyverse&quot;) library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 -- ## v ggplot2 3.3.5 v purrr 0.3.4 ## v tibble 3.1.2 v stringr 1.4.0 ## v tidyr 1.1.3 v forcats 0.5.1 ## v readr 1.4.0 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() # to tidyverse attached packages # tidyverse_packages(include_self = TRUE) 5.2 Exploring data with dplyr 5.2.1 Funtions and dataset explore For the next sample we are going to use gapminder dataset. The gapminder data frame include six variables: country, continent, year, lifeExp - life expectancy at birth, pop - total population, gdpPercap - per-capita GDP. Per-capita GDP (Gross domestic product) is given in units of international dollars, a hypothetical unit of currency that has the same purchasing power parity that the U.S. dollar had in the United States at a given point in time  2005, in this case. The gapminder data frame is a special kind of data frame: a tibble. #install.packages(&quot;gapminder&quot;) library(gapminder) # load package and dataset class(gapminder) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Lets preview it with functions str(), glimpse(), head(), tail(), summary(). str(gapminder) ## tibble [1,704 x 6] (S3: tbl_df/tbl/data.frame) ## $ country : Factor w/ 142 levels &quot;Afghanistan&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ continent: Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ year : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... ## $ lifeExp : num [1:1704] 28.8 30.3 32 34 36.1 ... ## $ pop : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ... ## $ gdpPercap: num [1:1704] 779 821 853 836 740 ... glimpse(gapminder) ## Rows: 1,704 ## Columns: 6 ## $ country &lt;fct&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, ~ ## $ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, ~ ## $ year &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, ~ ## $ lifeExp &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8~ ## $ pop &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12~ ## $ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, ~ head(gapminder) #shows first n-rows, 6 by default ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. tail(gapminder) #shows last n-rows, 6 by default ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Zimbabwe Africa 1982 60.4 7636524 789. ## 2 Zimbabwe Africa 1987 62.4 9216418 706. ## 3 Zimbabwe Africa 1992 60.4 10704340 693. ## 4 Zimbabwe Africa 1997 46.8 11404948 792. ## 5 Zimbabwe Africa 2002 40.0 11926563 672. ## 6 Zimbabwe Africa 2007 43.5 12311143 470. summary(gapminder) ## country continent year lifeExp ## Afghanistan: 12 Africa :624 Min. :1952 Min. :23.60 ## Albania : 12 Americas:300 1st Qu.:1966 1st Qu.:48.20 ## Algeria : 12 Asia :396 Median :1980 Median :60.71 ## Angola : 12 Europe :360 Mean :1980 Mean :59.47 ## Argentina : 12 Oceania : 24 3rd Qu.:1993 3rd Qu.:70.85 ## Australia : 12 Max. :2007 Max. :82.60 ## (Other) :1632 ## pop gdpPercap ## Min. :6.001e+04 Min. : 241.2 ## 1st Qu.:2.794e+06 1st Qu.: 1202.1 ## Median :7.024e+06 Median : 3531.8 ## Mean :2.960e+07 Mean : 7215.3 ## 3rd Qu.:1.959e+07 3rd Qu.: 9325.5 ## Max. :1.319e+09 Max. :113523.1 ## 5.2.2 filter() function austria &lt;- filter(gapminder, country == &quot;Austria&quot;) austria ## # A tibble: 12 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Austria Europe 1952 66.8 6927772 6137. ## 2 Austria Europe 1957 67.5 6965860 8843. ## 3 Austria Europe 1962 69.5 7129864 10751. ## 4 Austria Europe 1967 70.1 7376998 12835. ## 5 Austria Europe 1972 70.6 7544201 16662. ## 6 Austria Europe 1977 72.2 7568430 19749. ## 7 Austria Europe 1982 73.2 7574613 21597. ## 8 Austria Europe 1987 74.9 7578903 23688. ## 9 Austria Europe 1992 76.0 7914969 27042. ## 10 Austria Europe 1997 77.5 8069876 29096. ## 11 Austria Europe 2002 79.0 8148312 32418. ## 12 Austria Europe 2007 79.8 8199783 36126. filter() takes logical expressions and returns the rows for which all are TRUE. # task: select rows with lifeExp less than 31 filter(gapminder, lifeExp &lt; 31) ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Angola Africa 1952 30.0 4232095 3521. ## 4 Gambia Africa 1952 30 284320 485. ## 5 Rwanda Africa 1992 23.6 7290203 737. ## 6 Sierra Leone Africa 1952 30.3 2143249 880. # task: select Austria only and year after 1980 filter(gapminder, country == &quot;Austria&quot;, year &gt; 1980) ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Austria Europe 1982 73.2 7574613 21597. ## 2 Austria Europe 1987 74.9 7578903 23688. ## 3 Austria Europe 1992 76.0 7914969 27042. ## 4 Austria Europe 1997 77.5 8069876 29096. ## 5 Austria Europe 2002 79.0 8148312 32418. ## 6 Austria Europe 2007 79.8 8199783 36126. # task: select Austria and Belgium filter(gapminder, country %in% c(&quot;Austria&quot;, &quot;Belgium&quot;)) ## # A tibble: 24 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Austria Europe 1952 66.8 6927772 6137. ## 2 Austria Europe 1957 67.5 6965860 8843. ## 3 Austria Europe 1962 69.5 7129864 10751. ## 4 Austria Europe 1967 70.1 7376998 12835. ## 5 Austria Europe 1972 70.6 7544201 16662. ## 6 Austria Europe 1977 72.2 7568430 19749. ## 7 Austria Europe 1982 73.2 7574613 21597. ## 8 Austria Europe 1987 74.9 7578903 23688. ## 9 Austria Europe 1992 76.0 7914969 27042. ## 10 Austria Europe 1997 77.5 8069876 29096. ## # ... with 14 more rows 5.3 Pipe (%&gt;%) operator %&gt;% is pipe operator. The pipe operator takes the thing on the left-hand-side and pipes it into the function call on the right-hand-side  literally, drops it in as the first argument. In R version before 4.1.0 pipe %&gt;% operator is not a language build-in and you should install magrittr package: #install.packages(&quot;magrittr&quot;) # for pipe %&gt;% operator library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract head() function without pipe and top 4 items: head(gapminder, n = 4) ## # A tibble: 4 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. head() function with pipe and top 4 items: gapminder %&gt;% head(4) ## # A tibble: 4 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. Output is the same. So, lets rewrire filtering for Austria with pipe: austria &lt;- gapminder %&gt;% filter(country == &quot;Austria&quot;) austria ## # A tibble: 12 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Austria Europe 1952 66.8 6927772 6137. ## 2 Austria Europe 1957 67.5 6965860 8843. ## 3 Austria Europe 1962 69.5 7129864 10751. ## 4 Austria Europe 1967 70.1 7376998 12835. ## 5 Austria Europe 1972 70.6 7544201 16662. ## 6 Austria Europe 1977 72.2 7568430 19749. ## 7 Austria Europe 1982 73.2 7574613 21597. ## 8 Austria Europe 1987 74.9 7578903 23688. ## 9 Austria Europe 1992 76.0 7914969 27042. ## 10 Austria Europe 1997 77.5 8069876 29096. ## 11 Austria Europe 2002 79.0 8148312 32418. ## 12 Austria Europe 2007 79.8 8199783 36126. # add more conditions in filter austria &lt;- gapminder %&gt;% filter(country == &quot;Austria&quot;, year &gt; 2000) austria ## # A tibble: 2 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Austria Europe 2002 79.0 8148312 32418. ## 2 Austria Europe 2007 79.8 8199783 36126. 5.3.1 select() function Use select() to subset the data on variables/columns by names or index. You also can define order of columns with select(). gapminder %&gt;% select(year, country, pop) %&gt;% slice(1: 10) ## # A tibble: 10 x 3 ## year country pop ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; ## 1 1952 Afghanistan 8425333 ## 2 1957 Afghanistan 9240934 ## 3 1962 Afghanistan 10267083 ## 4 1967 Afghanistan 11537966 ## 5 1972 Afghanistan 13079460 ## 6 1977 Afghanistan 14880372 ## 7 1982 Afghanistan 12881816 ## 8 1987 Afghanistan 13867957 ## 9 1992 Afghanistan 16317921 ## 10 1997 Afghanistan 22227415 Finally, lest extend our filtering: # compare dplyr syntax with base R call gapminder[gapminder$country == &quot;Austria&quot;, c(&quot;year&quot;, &quot;pop&quot;, &quot;lifeExp&quot;)] ## # A tibble: 12 x 3 ## year pop lifeExp ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1952 6927772 66.8 ## 2 1957 6965860 67.5 ## 3 1962 7129864 69.5 ## 4 1967 7376998 70.1 ## 5 1972 7544201 70.6 ## 6 1977 7568430 72.2 ## 7 1982 7574613 73.2 ## 8 1987 7578903 74.9 ## 9 1992 7914969 76.0 ## 10 1997 8069876 77.5 ## 11 2002 8148312 79.0 ## 12 2007 8199783 79.8 gapminder %&gt;% filter(country == &quot;Austria&quot;) %&gt;% select(year, pop, lifeExp) ## # A tibble: 12 x 3 ## year pop lifeExp ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1952 6927772 66.8 ## 2 1957 6965860 67.5 ## 3 1962 7129864 69.5 ## 4 1967 7376998 70.1 ## 5 1972 7544201 70.6 ## 6 1977 7568430 72.2 ## 7 1982 7574613 73.2 ## 8 1987 7578903 74.9 ## 9 1992 7914969 76.0 ## 10 1997 8069876 77.5 ## 11 2002 8148312 79.0 ## 12 2007 8199783 79.8 You can remove some columns using minus(operator) and add few filter conditions: austria &lt;- gapminder %&gt;% filter(country == &quot;Austria&quot;, year &gt; 2000) %&gt;% select(-continent, -gdpPercap) %&gt;% head() austria ## # A tibble: 2 x 4 ## country year lifeExp pop ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Austria 2002 79.0 8148312 ## 2 Austria 2007 79.8 8199783 You can insert different conditions about columns you need to select. gapminder %&gt;% select(!where(is.numeric)) %&gt;% # its 1704 records, because of repeating some records slice(1:5) ## # A tibble: 5 x 2 ## country continent ## &lt;fct&gt; &lt;fct&gt; ## 1 Afghanistan Asia ## 2 Afghanistan Asia ## 3 Afghanistan Asia ## 4 Afghanistan Asia ## 5 Afghanistan Asia Lets output all unique pairs continent -&gt; country with distinct() function: gapminder %&gt;% select(country) %&gt;% distinct() # its 142 records now ## # A tibble: 142 x 1 ## country ## &lt;fct&gt; ## 1 Afghanistan ## 2 Albania ## 3 Algeria ## 4 Angola ## 5 Argentina ## 6 Australia ## 7 Austria ## 8 Bahrain ## 9 Bangladesh ## 10 Belgium ## # ... with 132 more rows ### Random sampling The sample_n() function selects random rows from a data frame r gapminder %&gt;% sample_n(5) ## # A tibble: 5 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 France Europe 1972 72.4 51732000 16107. ## 2 Trinidad and Tobago Americas 1962 64.9 887498 4998. ## 3 Vietnam Asia 1967 47.8 39463910 637. ## 4 Algeria Africa 2007 72.3 33333216 6223. ## 5 Switzerland Europe 1972 73.8 6401400 27195. If you want make pseudo-random generation reprodusable use set.seed(). Seed is start point of random generation. Different seeds give different output. r set.seed(2021) # example, seed = 2021 The sample_frac() function selects random fraction rows from a data frame. Lets select \\(1\\%\\) of data r set.seed(2021) # output not changing, uncomment it gapminder %&gt;% sample_frac(0.1) ## # A tibble: 170 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Libya Africa 1962 47.8 1441863 6757. ## 2 Botswana Africa 1997 52.6 1536536 8647. ## 3 Swaziland Africa 1957 43.4 326741 1245. ## 4 Dominican Republic Americas 1997 70.0 7992357 3614. ## 5 Iraq Asia 2002 57.0 24001816 4391. ## 6 Libya Africa 1987 66.2 3799845 11771. ## 7 Montenegro Europe 1967 67.2 501035 5908. ## 8 New Zealand Oceania 1957 70.3 2229407 12247. ## 9 Bulgaria Europe 2007 73.0 7322858 10681. ## 10 Malawi Africa 1997 47.5 10419991 692. ## # ... with 160 more rows 5.3.2 Subset rows using their positions with slice() Description slice() lets you index rows by their (integer) locations. It allows you to select, remove, and duplicate rows. It is accompanied by a number of helpers for common use cases: slice_head() and slice_tail() select the first or last rows. slice_sample() randomly selects rows. slice_min() and slice_max() select rows with highest or lowest values of a variable. If .data is a grouped_df, the operation will be performed on each group, so that (e.g.) slice_head(df, n = 5) will select the first five rows in each group. Samples gapminder %&gt;% slice(1) # top 1 row ## # A tibble: 1 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. gapminder %&gt;% slice(1:6) # top n = 6 ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. gapminder %&gt;% slice_head(n = 6) # works like head() ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. gapminder %&gt;% slice_tail(n = 5) # works like tail() ## # A tibble: 5 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Zimbabwe Africa 1987 62.4 9216418 706. ## 2 Zimbabwe Africa 1992 60.4 10704340 693. ## 3 Zimbabwe Africa 1997 46.8 11404948 792. ## 4 Zimbabwe Africa 2002 40.0 11926563 672. ## 5 Zimbabwe Africa 2007 43.5 12311143 470. You can drop some recods with negative indexes: gapminder %&gt;% slice(-c(1:3,5)) %&gt;% # remove Afganistan years 1952, 1957, 1962 and 1972 head(6) ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1967 34.0 11537966 836. ## 2 Afghanistan Asia 1977 38.4 14880372 786. ## 3 Afghanistan Asia 1982 39.9 12881816 978. ## 4 Afghanistan Asia 1987 40.8 13867957 852. ## 5 Afghanistan Asia 1992 41.7 16317921 649. ## 6 Afghanistan Asia 1997 41.8 22227415 635. # Random rows selection with slice_sample() gapminder %&gt;% slice_sample(n = 5) #use set.seed() to fix random ## # A tibble: 5 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Cambodia Asia 2002 56.8 12926707 896. ## 2 Poland Europe 2002 74.7 38625976 12002. ## 3 Bulgaria Europe 1972 70.9 8576200 6597. ## 4 Congo, Dem. Rep. Africa 1952 39.1 14100005 781. ## 5 Chad Africa 2002 50.5 8835739 1156. # Rows with minimum and maximum values of a variable # Lets find top 5 records with minimum and maximum lifeExp in all dataset gapminder %&gt;% slice_min(lifeExp, n = 5) ## # A tibble: 5 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Rwanda Africa 1992 23.6 7290203 737. ## 2 Afghanistan Asia 1952 28.8 8425333 779. ## 3 Gambia Africa 1952 30 284320 485. ## 4 Angola Africa 1952 30.0 4232095 3521. ## 5 Sierra Leone Africa 1952 30.3 2143249 880. gapminder %&gt;% slice_max(lifeExp, n = 5) ## # A tibble: 5 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Japan Asia 2007 82.6 127467972 31656. ## 2 Hong Kong, China Asia 2007 82.2 6980412 39725. ## 3 Japan Asia 2002 82 127065841 28605. ## 4 Iceland Europe 2007 81.8 301931 36181. ## 5 Switzerland Europe 2007 81.7 7554661 37506. 5.3.3 Sorting with arrange() arrange(.data, ) function order rows by values of a column or columns (low to high)You can use with desc() to order from high to low. For example, we need to select top 10 countries in 2002 by lifeExp variable. data2002 &lt;- gapminder %&gt;% filter(year == 2002) %&gt;% top_n(10, lifeExp) # select top 10 by lifeExp value data2002 ## # A tibble: 10 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Australia Oceania 2002 80.4 19546792 30688. ## 2 Canada Americas 2002 79.8 31902268 33329. ## 3 Hong Kong, China Asia 2002 81.5 6762476 30209. ## 4 Iceland Europe 2002 80.5 288030 31163. ## 5 Israel Asia 2002 79.7 6029529 21906. ## 6 Italy Europe 2002 80.2 57926999 27968. ## 7 Japan Asia 2002 82 127065841 28605. ## 8 Spain Europe 2002 79.8 40152517 24835. ## 9 Sweden Europe 2002 80.0 8954175 29342. ## 10 Switzerland Europe 2002 80.6 7361757 34481. # sort by pop t &lt;- gapminder %&gt;% arrange(continent) t &lt;- gapminder %&gt;% arrange(continent, country) t &lt;- gapminder %&gt;% arrange(continent, desc( country)) 5.3.4 Create new variables with mutate() mutate(.data, ) compute new column(s). Lets compute new column for data2002 \\(gdpTotal = gdpPercap * pop / 1000000\\). gapminder %&gt;% mutate(gdpTotal = gdpPercap * pop) %&gt;% head(10) ## # A tibble: 10 x 7 ## country continent year lifeExp pop gdpPercap gdpTotal ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. 6567086330. ## 2 Afghanistan Asia 1957 30.3 9240934 821. 7585448670. ## 3 Afghanistan Asia 1962 32.0 10267083 853. 8758855797. ## 4 Afghanistan Asia 1967 34.0 11537966 836. 9648014150. ## 5 Afghanistan Asia 1972 36.1 13079460 740. 9678553274. ## 6 Afghanistan Asia 1977 38.4 14880372 786. 11697659231. ## 7 Afghanistan Asia 1982 39.9 12881816 978. 12598563401. ## 8 Afghanistan Asia 1987 40.8 13867957 852. 11820990309. ## 9 Afghanistan Asia 1992 41.7 16317921 649. 10595901589. ## 10 Afghanistan Asia 1997 41.8 22227415 635. 14121995875. transmute(.data, ) compute new column(s), drop others. gapminder %&gt;% transmute(gdpTotal = gdpPercap * pop) %&gt;% head(10) ## # A tibble: 10 x 1 ## gdpTotal ## &lt;dbl&gt; ## 1 6567086330. ## 2 7585448670. ## 3 8758855797. ## 4 9648014150. ## 5 9678553274. ## 6 11697659231. ## 7 12598563401. ## 8 11820990309. ## 9 10595901589. ## 10 14121995875. You can mutate many columns at once: gapminder %&gt;% mutate(gdpTotal = gdpPercap * pop, countryUpper = toupper(country), # uppercase country lifeExpRounded = round(lifeExp)) %&gt;% head(10) ## # A tibble: 10 x 9 ## country continent year lifeExp pop gdpPercap gdpTotal countryUpper ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanist~ Asia 1952 28.8 8425333 779. 6.57e 9 AFGHANISTAN ## 2 Afghanist~ Asia 1957 30.3 9240934 821. 7.59e 9 AFGHANISTAN ## 3 Afghanist~ Asia 1962 32.0 10267083 853. 8.76e 9 AFGHANISTAN ## 4 Afghanist~ Asia 1967 34.0 11537966 836. 9.65e 9 AFGHANISTAN ## 5 Afghanist~ Asia 1972 36.1 13079460 740. 9.68e 9 AFGHANISTAN ## 6 Afghanist~ Asia 1977 38.4 14880372 786. 1.17e10 AFGHANISTAN ## 7 Afghanist~ Asia 1982 39.9 12881816 978. 1.26e10 AFGHANISTAN ## 8 Afghanist~ Asia 1987 40.8 13867957 852. 1.18e10 AFGHANISTAN ## 9 Afghanist~ Asia 1992 41.7 16317921 649. 1.06e10 AFGHANISTAN ## 10 Afghanist~ Asia 1997 41.8 22227415 635. 1.41e10 AFGHANISTAN ## # ... with 1 more variable: lifeExpRounded &lt;dbl&gt; You also can edit existing column (lets change continent Europe to EU in dataframe): data2002 %&gt;% mutate( continent = as.character(continent), # convert factor -&gt; character continent = ifelse(continent == &quot;Europe&quot;, &quot;EU&quot;, continent)) ## # A tibble: 10 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Australia Oceania 2002 80.4 19546792 30688. ## 2 Canada Americas 2002 79.8 31902268 33329. ## 3 Hong Kong, China Asia 2002 81.5 6762476 30209. ## 4 Iceland EU 2002 80.5 288030 31163. ## 5 Israel Asia 2002 79.7 6029529 21906. ## 6 Italy EU 2002 80.2 57926999 27968. ## 7 Japan Asia 2002 82 127065841 28605. ## 8 Spain EU 2002 79.8 40152517 24835. ## 9 Sweden EU 2002 80.0 8954175 29342. ## 10 Switzerland EU 2002 80.6 7361757 34481. 5.3.5 Renaming columns with rename() rename(.data, ) rename columns. Lets rename column pop to poulation: gapminder %&gt;% rename(population = pop) %&gt;% head(10) ## # A tibble: 10 x 6 ## country continent year lifeExp population gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. 5.3.6 Calculations with group_by() + summarise() group_by(.data, , add = FALSE) returns copy of table grouped by defined columns. Lets find average by lifeExp for each continent in 2002 (ouput is continent, lifeExpAvg2002, countriesCount, year = 2002): gapminder %&gt;% filter(year == 2002) %&gt;% # year group_by(continent, year) %&gt;% # grouping condition summarise( lifeExpAvg2002 = mean(lifeExp), countriesCount = n() # n() count of rows in group ) ## `summarise()` has grouped output by &#39;continent&#39;. You can override using the `.groups` argument. ## # A tibble: 5 x 4 ## # Groups: continent [5] ## continent year lifeExpAvg2002 countriesCount ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Africa 2002 53.3 52 ## 2 Americas 2002 72.4 25 ## 3 Asia 2002 69.2 33 ## 4 Europe 2002 76.7 30 ## 5 Oceania 2002 79.7 2 Lets find total population for each continent in 2002 (ouput is continent, totalPop, year): gapminder %&gt;% filter(year == 2002) %&gt;% # year group_by(continent, year) %&gt;% # grouping condition summarise( totalPop = sum(pop), .groups = &quot;keep&quot; ) ## # A tibble: 5 x 3 ## # Groups: continent, year [5] ## continent year totalPop ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Africa 2002 833723916 ## 2 Americas 2002 849772762 ## 3 Asia 2002 3601802203 ## 4 Europe 2002 578223869 ## 5 Oceania 2002 23454829 There are additional variations of summarise(): summarise_all() - Apply funs to every column. summarise_at() - Apply funs to specific columns. summarise_if() - Apply funs to all cols of one type. 5.3.7 Task on Credits library(ISLR) group_inc &lt;- aggregate(Income ~ Age + Gender, data = Credit, mean) m_data &lt;- group_inc[group_inc$Gender == &quot; Male&quot;, ] nrow(m_data) ## [1] 63 f_data &lt;- group_inc[group_inc$Gender == &quot;Female&quot;, ] nrow(f_data) ## [1] 62 with(m_data, plot(Age, Income, type = &quot;l&quot;, col=&quot;red&quot;)) with(f_data, lines(Age, Income, type = &quot;l&quot;, col =&quot;blue&quot;)) cd &lt;- Credit %&gt;% select(Income, Age, Gender) %&gt;% group_by(Age, Gender) %&gt;% summarize(Income = mean(Income)) ## `summarise()` has grouped output by &#39;Age&#39;. You can override using the `.groups` argument. m_data &lt;- cd %&gt;% filter(Gender == &quot; Male&quot;) nrow(m_data) ## [1] 63 f_data &lt;- cd %&gt;% filter(Gender == &quot;Female&quot;) nrow(f_data) ## [1] 62 with(m_data, plot(Age, Income, type = &quot;l&quot;, col=&quot;red&quot;)) with(f_data, lines(Age, Income, type = &quot;l&quot;, col =&quot;blue&quot;)) 5.3.8 Binding rows and columns bind_rows(.data, ) helps to unite two dataframes with the same columns order and names. So, if we need add one data frame to an other vertically (bind rows) we shoul use bind_rows: grouped_data2002 &lt;- gapminder %&gt;% filter(year == 2002) %&gt;% # year group_by(continent, year) %&gt;% # grouping condition summarise( lifeExpAvg = mean(lifeExp), countriesCount = n() # n() count of rows in group ) ## `summarise()` has grouped output by &#39;continent&#39;. You can override using the `.groups` argument. d2007 &lt;- gapminder %&gt;% filter(year == 2007) %&gt;% # year group_by(continent, year) %&gt;% # grouping condition summarise( lifeExpAvg = mean(lifeExp), countriesCount = n() # n() count of rows in group ) ## `summarise()` has grouped output by &#39;continent&#39;. You can override using the `.groups` argument. Unite them: grouped_data2002 %&gt;% bind_rows(d2007) ## bind rows ## # A tibble: 10 x 4 ## # Groups: continent [5] ## continent year lifeExpAvg countriesCount ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Africa 2002 53.3 52 ## 2 Americas 2002 72.4 25 ## 3 Asia 2002 69.2 33 ## 4 Europe 2002 76.7 30 ## 5 Oceania 2002 79.7 2 ## 6 Africa 2007 54.8 52 ## 7 Americas 2007 73.6 25 ## 8 Asia 2007 70.7 33 ## 9 Europe 2007 77.6 30 ## 10 Oceania 2007 80.7 2 bind_cols(.data, ) helps to unite two dataframes with the same rows count. grouped_data2002pop &lt;- gapminder %&gt;% filter(year == 2002) %&gt;% # year group_by(continent) %&gt;% # grouping condition summarise( totalPop = sum(pop) ) %&gt;% mutate(year = 2002) grouped_data2002pop ## # A tibble: 5 x 3 ## continent totalPop year ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 833723916 2002 ## 2 Americas 849772762 2002 ## 3 Asia 3601802203 2002 ## 4 Europe 578223869 2002 ## 5 Oceania 23454829 2002 Lets combine grouped_data2002 and popgrouped_data2002pop: grouped_data &lt;- grouped_data2002 %&gt;% bind_cols(grouped_data2002pop) ## New names: ## * continent -&gt; continent...1 ## * year -&gt; year...2 ## * continent -&gt; continent...5 ## * year -&gt; year...7 grouped_data ## # A tibble: 5 x 7 ## continent...1 year...2 lifeExpAvg countriesCount continent...5 totalPop ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 Africa 2002 53.3 52 Africa 833723916 ## 2 Americas 2002 72.4 25 Americas 849772762 ## 3 Asia 2002 69.2 33 Asia 3601802203 ## 4 Europe 2002 76.7 30 Europe 578223869 ## 5 Oceania 2002 79.7 2 Oceania 23454829 ## # ... with 1 more variable: year...7 &lt;dbl&gt; # columns with the same name were renamed! You can remove same named variables before binding: grouped_data &lt;- grouped_data2002 %&gt;% bind_cols(grouped_data2002pop %&gt;% select(-continent, -year)) grouped_data ## # A tibble: 5 x 5 ## # Groups: continent [5] ## continent year lifeExpAvg countriesCount totalPop ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Africa 2002 53.3 52 833723916 ## 2 Americas 2002 72.4 25 849772762 ## 3 Asia 2002 69.2 33 3601802203 ## 4 Europe 2002 76.7 30 578223869 ## 5 Oceania 2002 79.7 2 23454829 # better, but continents order is not the same in both frames # your data is going to be damaged grouped_data2002pop &lt;- grouped_data2002pop %&gt;% arrange(totalPop) grouped_data &lt;- grouped_data2002 %&gt;% bind_cols(grouped_data2002pop) grouped_data # you can see that continent fields different in the same row 5.3.9 Join()ing data To solve previous problem you can use set of join()-functions. left_join() can solve our previous example: grouped_data2002pop &lt;- grouped_data2002pop %&gt;% arrange(totalPop) grouped_data &lt;- grouped_data2002 %&gt;% left_join(grouped_data2002pop, by = &quot;continent&quot;) grouped_data ## # A tibble: 5 x 6 ## # Groups: continent [5] ## continent year.x lifeExpAvg countriesCount totalPop year.y ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 2002 53.3 52 833723916 2002 ## 2 Americas 2002 72.4 25 849772762 2002 ## 3 Asia 2002 69.2 33 3601802203 2002 ## 4 Europe 2002 76.7 30 578223869 2002 ## 5 Oceania 2002 79.7 2 23454829 2002 # but we have duplicated year grouped_data2002pop &lt;- grouped_data2002pop %&gt;% arrange(totalPop) grouped_data &lt;- grouped_data2002 %&gt;% left_join(grouped_data2002pop, by = c(&quot;continent&quot;, &quot;year&quot;)) grouped_data ## # A tibble: 5 x 5 ## # Groups: continent [5] ## continent year lifeExpAvg countriesCount totalPop ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Africa 2002 53.3 52 833723916 ## 2 Americas 2002 72.4 25 849772762 ## 3 Asia 2002 69.2 33 3601802203 ## 4 Europe 2002 76.7 30 578223869 ## 5 Oceania 2002 79.7 2 23454829 #ok Lets make a different data sets for testing join() fucntions: first_df &lt;- data.frame(Letter = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;), Value = c(1:5)) second_df &lt;- data.frame(Letter = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;), Value = c(12, 7, 4, 1, 5)) first_df ## Letter Value ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 second_df ## Letter Value ## 1 A 12 ## 2 B 7 ## 3 C 4 ## 4 D 1 ## 5 F 5 You can see that the last row Letter is different in dataframes. left_join() test is next. first_df %&gt;% left_join(second_df, by = &quot;Letter&quot;) ## Letter Value.x Value.y ## 1 A 1 12 ## 2 B 2 7 ## 3 C 3 4 ## 4 D 4 1 ## 5 E 5 NA # there is no F letter, becouse first_db joined only known first_df Letters. first_df %&gt;% right_join(second_df, by = &quot;Letter&quot;) ## Letter Value.x Value.y ## 1 A 1 12 ## 2 B 2 7 ## 3 C 3 4 ## 4 D 4 1 ## 5 F NA 5 # right_join! there is no E letter, becouse first_db joined only known second_df Letters. first_df %&gt;% inner_join(second_df, by = &quot;Letter&quot;) ## Letter Value.x Value.y ## 1 A 1 12 ## 2 B 2 7 ## 3 C 3 4 ## 4 D 4 1 # inner_join! there is no E and F Letters, # only known both first_df and second_df are left here. first_df %&gt;% full_join(second_df, by = &quot;Letter&quot;) ## Letter Value.x Value.y ## 1 A 1 12 ## 2 B 2 7 ## 3 C 3 4 ## 4 D 4 1 ## 5 E 5 NA ## 6 F NA 5 # all are here, but unknown values replaced by NA, it&#39;s ok. Short description of reviewed functions: left_join() Merge two datasets. Keep all observations from the origin table right_join() Merge two datasets. Keep all observations from the destination table inner_join() Merge two datasets. Excludes all unmatched rows full_join() Merge two datasets. Keeps all observations 5.3.10 Data cleaning with gather() Some times your data is not in tidy format. Peole can collect data year by year in each column. Its problem to use such data for feature engeniering and building prediction models. Lets generate such data sample (quaterly salary of some people). not_good_data &lt;- data.frame(Name = c(&quot;Nick&quot;, &quot;Jake&quot;, &quot;Anna&quot;, &quot;Jane&quot;, &quot;Dina&quot;), q1_2021 = c(12442, 22131, 21343, 22111, 14123), q2_2021 = c(13442, 22871, 20343, 22222, 14456), q3_2021 = c(15482, 22031, 22456, 22444, 14533), q4_2021 = c(14511, 20031, 21741, 22333, 14511)) not_good_data ## Name q1_2021 q2_2021 q3_2021 q4_2021 ## 1 Nick 12442 13442 15482 14511 ## 2 Jake 22131 22871 22031 20031 ## 3 Anna 21343 20343 22456 21741 ## 4 Jane 22111 22222 22444 22333 ## 5 Dina 14123 14456 14533 14511 better_data &lt;- not_good_data %&gt;% gather(quater, salary, 2:5) # gather(quater, salary, q1_2021:q4_2021) possible code too better_data ## Name quater salary ## 1 Nick q1_2021 12442 ## 2 Jake q1_2021 22131 ## 3 Anna q1_2021 21343 ## 4 Jane q1_2021 22111 ## 5 Dina q1_2021 14123 ## 6 Nick q2_2021 13442 ## 7 Jake q2_2021 22871 ## 8 Anna q2_2021 20343 ## 9 Jane q2_2021 22222 ## 10 Dina q2_2021 14456 ## 11 Nick q3_2021 15482 ## 12 Jake q3_2021 22031 ## 13 Anna q3_2021 22456 ## 14 Jane q3_2021 22444 ## 15 Dina q3_2021 14533 ## 16 Nick q4_2021 14511 ## 17 Jake q4_2021 20031 ## 18 Anna q4_2021 21741 ## 19 Jane q4_2021 22333 ## 20 Dina q4_2021 14511 To make our data tidier separate() can split quater column into 2 (quater and year): best_data &lt;- better_data %&gt;% separate(quater, c(&quot;quater&quot;, &quot;year&quot;), sep = &quot;_&quot;) %&gt;% # separate mutate(year = as.integer(year), # convert year to integer quater = substr(better_data$quater, 2,2), # trim `q` from start quater = as.integer(quater), # convert quater to integer ) %&gt;% head(10) best_data ## Name quater year salary ## 1 Nick 1 2021 12442 ## 2 Jake 1 2021 22131 ## 3 Anna 1 2021 21343 ## 4 Jane 1 2021 22111 ## 5 Dina 1 2021 14123 ## 6 Nick 2 2021 13442 ## 7 Jake 2 2021 22871 ## 8 Anna 2 2021 20343 ## 9 Jane 2 2021 22222 ## 10 Dina 2 2021 14456 The unite() function concanates two columns into one: united_data &lt;- best_data %&gt;% unite(Qt, quater, year, sep = &quot;#&quot;) united_data ## Name Qt salary ## 1 Nick 1#2021 12442 ## 2 Jake 1#2021 22131 ## 3 Anna 1#2021 21343 ## 4 Jane 1#2021 22111 ## 5 Dina 1#2021 14123 ## 6 Nick 2#2021 13442 ## 7 Jake 2#2021 22871 ## 8 Anna 2#2021 20343 ## 9 Jane 2#2021 22222 ## 10 Dina 2#2021 14456 # if dont want remove old columns use remove param united_data &lt;- best_data %&gt;% unite(Qt, quater, year, sep = &quot;#&quot;, remove = F) united_data ## Name Qt quater year salary ## 1 Nick 1#2021 1 2021 12442 ## 2 Jake 1#2021 1 2021 22131 ## 3 Anna 1#2021 1 2021 21343 ## 4 Jane 1#2021 1 2021 22111 ## 5 Dina 1#2021 1 2021 14123 ## 6 Nick 2#2021 2 2021 13442 ## 7 Jake 2#2021 2 2021 22871 ## 8 Anna 2#2021 2 2021 20343 ## 9 Jane 2#2021 2 2021 22222 ## 10 Dina 2#2021 2 2021 14456 If you need to make table like initial use spread() function: not_good_data2 &lt;- better_data %&gt;% spread(quater, salary) not_good_data2 ## Name q1_2021 q2_2021 q3_2021 q4_2021 ## 1 Anna 21343 20343 22456 21741 ## 2 Dina 14123 14456 14533 14511 ## 3 Jake 22131 22871 22031 20031 ## 4 Jane 22111 22222 22444 22333 ## 5 Nick 12442 13442 15482 14511 Lets try to spread() feild pop of gapminder by year: gapminder %&gt;% select(country, pop, year) %&gt;% spread(year, pop) %&gt;% head() # for shorter code ## # A tibble: 6 x 13 ## country `1952` `1957` `1962` `1967` `1972` `1977` `1982` `1987` `1992` `1997` ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghani~ 8.43e6 9.24e6 1.03e7 1.15e7 1.31e7 1.49e7 1.29e7 1.39e7 1.63e7 2.22e7 ## 2 Albania 1.28e6 1.48e6 1.73e6 1.98e6 2.26e6 2.51e6 2.78e6 3.08e6 3.33e6 3.43e6 ## 3 Algeria 9.28e6 1.03e7 1.10e7 1.28e7 1.48e7 1.72e7 2.00e7 2.33e7 2.63e7 2.91e7 ## 4 Angola 4.23e6 4.56e6 4.83e6 5.25e6 5.89e6 6.16e6 7.02e6 7.87e6 8.74e6 9.88e6 ## 5 Argenti~ 1.79e7 1.96e7 2.13e7 2.29e7 2.48e7 2.70e7 2.93e7 3.16e7 3.40e7 3.62e7 ## 6 Austral~ 8.69e6 9.71e6 1.08e7 1.19e7 1.32e7 1.41e7 1.52e7 1.63e7 1.75e7 1.86e7 ## # ... with 2 more variables: 2002 &lt;int&gt;, 2007 &lt;int&gt; # now you can easy send data to your director in excel :) Functions: gather() Transform the data from wide to long / (data, key, value, na.rm = FALSE) spread() Transform the data from long to wide / (data, key, value) separate() Split one variables into two / (data, col, into, sep= \"\", remove = TRUE) unite() Unite two variables into one / (data, col, conc ,sep= \"\", remove = TRUE) 5.4 Refences dplyr: A Grammar of Data Manipulation on https://cran.r-project.org/. Data Transformation with splyr::cheat sheet. DPLYR TUTORIAL : DATA MANIPULATION (50 EXAMPLES) by Deepanshu Bhalla. Dplyr Intro by Stat 545. 6.R Dplyr Tutorial: Data Manipulation(Join) &amp; Cleaning(Spread). Introduction to Data Analysis Loan Default Prediction. Beginners data set for financial analytics Kaggle "],["chapter8.html", " 6 8.    .", "  6 8.    .     .        ,      https://github.com/kleban/r: 035_ETL. Charts.ipynb "],["chapter7.html", " 7 7.     ,    .", "  7 7.     ,    .     .        ,      https://github.com/kleban/r: 033_ETL. Train Test Validation.ipynb 034_ETL. Feature engineering in R.ipynb 051_Regs. Linear Regression.ipynb 052_Regs. Linear Regression.ipynb 053_Regs. Logistic Regression.ipynb 061_Trees.Decision Tree. Classification.ipynb "],["chapter6.html", " 8      8.1  8.2  ", "  8                 8.1  8.1.1  8.1.1.1   ,   \\(y = (x+2)^2 + ln(x)\\),  \\(x\\)    100, 105, 110, ..., 200.     data.fame   \\(X\\)  \\(Y\\). 8.1.1.2   ,   \\(y = \\frac{\\sqrt{x+2}}{z}\\),  \\(x\\)    10, 15, 20, ..., 100,  \\(z\\) -     [-10, 10],      \\(x\\).     data.fame   \\(X\\), \\(Z\\)  \\(Y\\). 8.1.1.3       ,       .        [10,100).     10. 8.1.1.4     ,       ,     ,          .        [-100,100].     10. ,    x   : x &lt;- c(1, -5, 10, -8, -2, 5, 4, -9)      : ## [1] 1 10 5 4 -5 -8 -2 -9 8.1.1.5     \\(N\\) (  ).    . 8.1.1.6    .     ,      . 8.1.1.7        ,   .     :        ,     ;         . 8.1.1.8         \\(A\\),      \\(B\\). 8.1.1.9   ,        .        \\([1; 10)\\).    10. 8.1.1.10   ,      .        \\([100; 200]\\).       \\(7\\)-.  1.     \\(7\\)-    .  2.  ,   1  size ( )     . func.genMod7 &lt;- function() { x &lt;- 8 while(x %% 7 != 0) { x &lt;- sample(100:200, size = 1) } return(x) } func.genVectorMod7 &lt;- function(size) { v &lt;- c() for(i in 1:size) { v &lt;- c(v, func.genMod7()) } return(v) } vector &lt;- func.genVectorMod7(100) vector ## [1] 119 126 112 133 126 161 154 175 140 105 154 182 105 105 175 182 119 133 ## [19] 189 182 168 168 161 189 196 154 119 196 168 147 112 168 133 126 154 119 ## [37] 168 182 112 168 196 161 196 133 196 189 119 168 175 196 161 182 133 147 ## [55] 112 119 154 140 147 182 196 112 196 161 182 133 133 182 161 126 196 105 ## [73] 105 196 147 126 126 182 133 126 126 196 196 161 182 161 154 126 175 175 ## [91] 133 196 196 133 126 133 126 119 175 119 8.1.1.11   ,          ,    min()  max().        \\([10;50]\\). 8.1.1.12   ,          ,    min()  max().        \\([10;50]\\). 8.1.1.13 *  ,          . , a &lt;- 10  b &lt;- 25,         : print(a) ## [1] 25 print(b) ## [1] 10 8.1.1.14   ,  8.1.1.15     kaggle.com     (https://www.kaggle.com/ajaypalsinghlo/world-happiness-report-2021).    R. 8.1.2  8.1.2.1   ,      , , ,   .        (list). 8.2   8.2.1       6.1.1.3: x &lt;- sample(10:100, size = 10) for(j in 1:(length(x)-1)) { for(i in 1:(length(x)-1)) { if(x[i] &gt; x[i+1]) { tmp = x[i] x[i] = x[i+1] x[i+1] = tmp } } } print(x) ## [1] 21 22 40 46 63 65 75 77 91 96    6.1.1.4: x &lt;- sample(-100:100, size = 10) print(&quot;Vector before sort:&quot;) ## [1] &quot;Vector before sort:&quot; print(x) ## [1] 95 -2 -75 -31 90 35 -60 45 0 46 for(j in 1:(length(x)-1)) { for(i in 1:(length(x)-1)) { if(x[i] &lt; 0 &amp; x[i+1] &gt; 0) { tmp = x[i] x[i] = x[i+1] x[i+1] = tmp } } } print(&quot;Vector after sort:&quot;) ## [1] &quot;Vector after sort:&quot; print(x) ## [1] 95 90 35 45 -2 -75 -31 -60 0 46    6.1.1.5: #number &lt;- as.numeric(readline(prompt = &quot; :&quot;)) number &lt;- 15783 sum &lt;- 0 while(number &gt; 0) { last_digit = number %% 10 sum = sum + last_digit number = (number - last_digit) / 10 print(paste0(&quot;Number: &quot;, number, &quot; | Sum: &quot;, sum, &quot; | Last: &quot;, last_digit)) } ## [1] &quot;Number: 1578 | Sum: 3 | Last: 3&quot; ## [1] &quot;Number: 157 | Sum: 11 | Last: 8&quot; ## [1] &quot;Number: 15 | Sum: 18 | Last: 7&quot; ## [1] &quot;Number: 1 | Sum: 23 | Last: 5&quot; ## [1] &quot;Number: 0 | Sum: 24 | Last: 1&quot;    6.1.1.9 ( 1): x &lt;- sample(1:10, size = 4, replace = T) x ## [1] 10 7 1 1 x_parni &lt;- c() for(i in 1:length(x)) { if(x[i] %% 2 == 0) { x_parni &lt;- c(x_parni, x[i]) } } mean(x_parni) ## [1] 10    6.1.1.9 ( 2): x &lt;- sample(1:10, size = 10, replace = T) x ## [1] 2 8 10 6 9 1 10 2 1 5 sum &lt;- 0 count &lt;- 0 for(i in 1:length(x)) { if(x[i] %% 2 == 0) { sum = sum + x[i] count = count + 1 } } mean_value = sum / count mean_value ## [1] 6.333333 8.2.2     6.1.2.1: x &lt;- sample(10:100, size = 10) print(x) ## [1] 86 16 88 24 35 14 80 71 73 15 vector.info &lt;- function(vector) { x &lt;- list() x$Sum &lt;- sum(vector) x$Mean &lt;- mean(vector) x$Median &lt;- median(vector) x$Min &lt;- min(vector) x$Max &lt;- max(vector) return(x) } vector.info(x) ## $Sum ## [1] 502 ## ## $Mean ## [1] 50.2 ## ## $Median ## [1] 53 ## ## $Min ## [1] 14 ## ## $Max ## [1] 88 Sys.setlocale(&quot;LC_CTYPE&quot;, &quot;ukrainian&quot;) "],["-e-.html", "e", " e "]]
